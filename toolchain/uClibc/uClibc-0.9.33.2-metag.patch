diff --git a/Makerules b/Makerules
index 7153836..ec9b4fe 100644
--- a/Makerules
+++ b/Makerules
@@ -300,7 +300,7 @@ define create-lds
 	-Wl,-z,relro -Wl,--hash-style=gnu -Wl,-z,defs \
 	-Wl,--verbose 2>&1 | LC_ALL=C \
 	sed -e '/^=========/,/^=========/!d;/^=========/d' \
-	-e 's/\. = .* + SIZEOF_HEADERS;/& _begin = . - SIZEOF_HEADERS;/' > $@.lds
+	-e 's/\. = .* + SIZEOF_HEADERS;/& $(SYMBOL_PREFIX)_begin = . - SIZEOF_HEADERS;/' > $@.lds
 endef
 
 define link.so
diff --git a/Rules.mak b/Rules.mak
index 11848fa..a19d5f2 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -397,6 +397,11 @@ ifeq ($(TARGET_ARCH),arm)
 	CPU_CFLAGS-$(COMPILE_IN_THUMB_MODE)+=-mthumb
 endif
 
+ifeq ($(TARGET_ARCH),metag)
+	CPU_CFLAGS-$(CONFIG_META_1_2)+=
+	CPU_CFLAGS-$(CONFIG_META_2_1)+=-Wa,-mcpu=metac21
+endif
+
 ifeq ($(TARGET_ARCH),mips)
 	OPTIMIZATION+=-mno-split-addresses
 	CPU_CFLAGS-$(CONFIG_MIPS_ISA_1)+=-mips1
@@ -542,6 +547,11 @@ PIEFLAG := $(CFLAG_$(PIEFLAG_NAME))
 ifeq ($(PIEFLAG),)
 PIEFLAG := $(PICFLAG)
 endif
+
+ifeq ($(TARGET_ARCH),metag)
+      SYMBOL_PREFIX=_
+endif
+
 # We need to keep track of both the CC PIE flag (above) as
 # well as the LD PIE flag (below) because we can't rely on
 # gcc passing -pie if we used -fPIE. We need to directly use -pie
@@ -658,15 +668,7 @@ LDFLAGS_NOSTRIP+=-Wl,-z,now
 endif
 
 ifeq ($(LDSO_GNU_HASH_SUPPORT),y)
-# Be sure that binutils support it
-$(eval $(call check-ld-var,--hash-style=gnu))
-ifeq ($(LDFLAG_--hash-style=gnu),)
-ifneq ($(filter-out $(clean_targets) CLEAN_% install_headers headers-y,$(MAKECMDGOALS)),)
-$(error Your binutils do not support --hash-style option, while you want to use it)
-endif
-else
-LDFLAGS_NOSTRIP += $(CFLAG_-Wl--hash-style=gnu)
-endif
+LDFLAGS_NOSTRIP += -Wl,--hash-style=gnu
 endif
 
 LDFLAGS:=$(LDFLAGS_NOSTRIP) -Wl,-z,defs
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 1060729..32cace9 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -81,6 +81,9 @@ config TARGET_ia64
 config TARGET_m68k
 	bool "m68k"
 
+config TARGET_metag
+        bool "metag"
+
 config TARGET_microblaze
 	bool "microblaze"
 
@@ -174,6 +177,10 @@ if TARGET_m68k
 source "extra/Configs/Config.m68k"
 endif
 
+if TARGET_metag
+source "extra/Configs/Config.metag"
+endif
+
 if TARGET_nios
 source "extra/Configs/Config.nios"
 endif
@@ -482,6 +489,7 @@ config HAS_NO_THREADS
 config LINUXTHREADS_OLD
 	bool "older (stable) version of linuxthreads"
 	# linuxthreads and linuxthreads.old need nanosleep()
+	depends on !ARCH_HAS_NO_DEPRECATED_SYSCALLS
 	select UCLIBC_HAS_REALTIME
 	help
 	  There are two versions of linuxthreads.  The older (stable) version
@@ -491,6 +499,7 @@ config LINUXTHREADS_OLD
 
 config LINUXTHREADS_NEW
 	bool "slightly newer version of linuxthreads"
+	depends on !ARCH_HAS_NO_DEPRECATED_SYSCALLS
 	help
 	  The new version has not been tested much, and lacks ports for arches
 	  which glibc does not support (like bfin/frv/etc...), but is based on
diff --git a/extra/Configs/Config.in.arch b/extra/Configs/Config.in.arch
index ec541f4..23b561d 100644
--- a/extra/Configs/Config.in.arch
+++ b/extra/Configs/Config.in.arch
@@ -42,6 +42,24 @@ if ARCH_USE_MMU
 comment "Using ELF file format"
 endif
 
+config ARCH_HAS_NO_OLD_IPC
+	bool "Disable support for the old IPC interface"
+	default n
+	help
+	  New architectures do not define the ARCH_WANT_IPC_PARSE_VERSION
+	  in their kernel, which means they have no support for the old IPC
+	  interface. For these architectures, these symbol must be defined
+	  in order to have functional semctl, shmctl and msgctl system calls
+
+config ARCH_HAS_NO_DEPRECATED_SYSCALLS
+	bool "Target architecture does not support the deprecated system calls"
+	default n
+	help
+	  New architectures do not support deprecated system calls. However,
+	  these system calls are needed to build linuxthreads (old and new) so
+	  this symbol controls whether there is support for these thread libraries
+	  or not.
+
 config UCLIBC_SHARED_FLAT_ID
 	int "Shared library ID"
 	default 1
diff --git a/extra/Configs/Config.metag b/extra/Configs/Config.metag
new file mode 100644
index 0000000..fe14fce
--- /dev/null
+++ b/extra/Configs/Config.metag
@@ -0,0 +1,33 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	default "metag"
+
+config FORCE_OPTIONS_FOR_ARCH
+        bool
+        default y
+        select ARCH_LITTLE_ENDIAN
+        select ARCH_HAS_MMU
+        select ARCH_HAS_NO_OLD_IPC
+        select ARCH_HAS_NO_DEPRECATED_SYSCALLS
+
+config ARCH_CFLAGS
+        string
+
+choice
+        prompt "Target Processor Type"
+        default CONFIG_META_1_2
+        help
+          This is the processor type of your CPU. This information is used for
+          optimizing purposes.
+
+config CONFIG_META_1_2
+	bool "Meta 1.2"
+
+config CONFIG_META_2_1
+	bool "Meta 2.1"
+
+endchoice
diff --git a/extra/locale/Makefile.in b/extra/locale/Makefile.in
index 221a515..ad48d31 100644
--- a/extra/locale/Makefile.in
+++ b/extra/locale/Makefile.in
@@ -205,16 +205,7 @@ endif
 
 ifeq ($(UCLIBC_PREGENERATED_LOCALE_DATA),y)
 
-$(locale_SRC): $(locale_OUT)/$(LOCALE_DATA_FILENAME)
-	zcat $< | $(TAR) -xv -C $(@D) -f -
-	touch $@
-	# we use the one in locale_DIR
-	#$(RM) $(locale_OUT)/locale_mmap.h
-
-# for arch specific versions we have to at least overwrite
-# lt_defines.h/locale_data.c/uClibc_locale_data.h
-
-$(locale_OUT)/uClibc_locale_data.h: $(locale_SRC)
+# For META we need to build our own locale data, it's check in.
 
 else
 
@@ -238,5 +229,5 @@ objclean-y += CLEAN_extra/locale
 
 # lmmtolso.c/gen_mmap.c/tst-*.c not used
 CLEAN_extra/locale:
-	$(do_rm) $(locale_HOBJ) $(locale_SRC) $(addprefix $(locale_OUT)/*., o os txt) \
-		$(addprefix $(locale_OUT)/,$(addsuffix .h,uClibc_locale_data lt_defines c8tables wctables locale_tables locale_collate) lmmtolso gen_mmap locale.mmap)
+	$(do_rm) $(locale_HOBJ) $(addprefix $(locale_OUT)/*., o os txt) \
+		$(addprefix $(locale_OUT)/, lmmtolso gen_mmap locale.mmap)
diff --git a/extra/locale/gen_wc8bit.c b/extra/locale/gen_wc8bit.c
index a861caa..1d42d3c 100644
--- a/extra/locale/gen_wc8bit.c
+++ b/extra/locale/gen_wc8bit.c
@@ -182,7 +182,7 @@ int main(int argc, char **argv)
 	printf("\tunsigned char idx8c2wc[%d];\n", C2WC_IDX_LEN);
 	printf("\tunsigned char idx8wc2c[%d];\n", II_LEN);
 #endif
-	printf("} __codeset_8_bit_t;\n\n");
+	printf("} __attribute__((__packed__)) __codeset_8_bit_t;\n\n");
 
 	printf("#ifdef WANT_DATA\n\n");
 	printf("static const __codeset_8_bit_t codeset_8_bit[%d] = {\n", argc-1);
diff --git a/extra/scripts/gen_bits_syscall_h.sh b/extra/scripts/gen_bits_syscall_h.sh
index f6353ba..fd141f0 100755
--- a/extra/scripts/gen_bits_syscall_h.sh
+++ b/extra/scripts/gen_bits_syscall_h.sh
@@ -40,7 +40,8 @@ $CC -E $INCLUDE_OPTS - |
   sed -ne 's/^UCLIBC\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\) *\(.*\)/#undef \1\2\
 #define \1\2 \3\
 #define SYS_\2 \1\2/gp' \
-     -e 's/^UNDEFUCLIBC\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\).*/#undef \1\2/gp'
+     -e 's/^UNDEFUCLIBC\(__ARM_NR_\|__NR_\)\([A-Za-z0-9_]*\).*/#undef \1\2\
+#undef SYS_\2/gp'
   echo ;
   echo "#endif" ;
 )
diff --git a/include/elf.h b/include/elf.h
index ba3e804..b72b4c0 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -282,6 +282,9 @@ typedef struct
    unofficial e_machine number should eventually ask registry@caldera.com for
    an officially blessed number to be added to the list above.  */
 
+/* Imagination Technologies META */
+#define EM_METAG        174
+
 /* picoJava */
 #define EM_PJ_OLD	99
 
@@ -3141,6 +3144,52 @@ typedef Elf32_Addr Elf32_Conflict;
 #define R_MICROBLAZE_COPY 21  /* runtime copy */
 #define R_MICROBLAZE_NUM 22
 
+/* META relocations */
+#define R_METAG_HIADDR16                 0
+#define R_METAG_LOADDR16                 1
+#define R_METAG_ADDR32                   2
+#define R_METAG_NONE                     3
+#define R_METAG_RELBRANCH                4
+#define R_METAG_GETSETOFF                5
+
+/* Backward compatability */
+#define R_METAG_REG32OP1                 6
+#define R_METAG_REG32OP2                 7
+#define R_METAG_REG32OP3                 8
+#define R_METAG_REG16OP1                 9
+#define R_METAG_REG16OP2                10
+#define R_METAG_REG16OP3                11
+#define R_METAG_REG32OP4                12
+
+#define R_METAG_HIOG                    13
+#define R_METAG_LOOG                    14
+
+/* GNU */
+#define R_METAG_GNU_VTINHERIT           30
+#define R_METAG_GNU_VTENTRY             31
+
+/* PIC relocations */
+#define R_METAG_HI16_GOTOFF             32
+#define R_METAG_LO16_GOTOFF             33
+#define R_METAG_GETSET_GOTOFF           34
+#define R_METAG_GETSET_GOT              35
+#define R_METAG_HI16_GOTPC              36
+#define R_METAG_LO16_GOTPC              37
+#define R_METAG_HI16_PLT                38
+#define R_METAG_LO16_PLT                39
+#define R_METAG_RELBRANCH_PLT           40
+#define R_METAG_GOTOFF                  41
+#define R_METAG_PLT                     42
+#define R_METAG_COPY                    43
+#define R_METAG_JMP_SLOT                44
+#define R_METAG_RELATIVE                45
+#define R_METAG_GLOB_DAT                46
+
+/* TLS relocations */
+#define R_METAG_TLS_TPOFF               56
+#define R_METAG_TLS_DTPMOD              57
+#define R_METAG_TLS_DTPOFF              58
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/include/unistd.h b/include/unistd.h
index 1b2fd4d..82e24a4 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -513,6 +513,10 @@ extern int dup (int __fd) __THROW __wur;
 extern int dup2 (int __fd, int __fd2) __THROW;
 libc_hidden_proto(dup2)
 
+/* Duplicate FD to FD2, closing FD2 and making it open on the same file. */
+extern int dup3 (int __fd, int __fd2, int __flags) __THROW;
+libc_hidden_proto(dup3)
+
 /* NULL-terminated array of "NAME=VALUE" environment variables.  */
 extern char **__environ;
 #ifdef __USE_GNU
diff --git a/ldso/include/dl-string.h b/ldso/include/dl-string.h
index a7e2f47..60bf31a 100644
--- a/ldso/include/dl-string.h
+++ b/ldso/include/dl-string.h
@@ -286,7 +286,8 @@ static __always_inline char * _dl_simple_ltoahex(char *local, unsigned long i)
  * This requires that load_addr must already be defined... */
 #if defined(mc68000)  || defined(__arm__) || defined(__thumb__) || \
     defined(__mips__) || defined(__sh__)  || defined(__powerpc__) || \
-    defined(__avr32__) || defined(__xtensa__) || defined(__sparc__) || defined(__microblaze__)
+    defined(__avr32__) || defined(__xtensa__) || defined(__sparc__) || \
+    defined(__microblaze__) || defined(__metag__)
 # define CONSTANT_STRING_GOT_FIXUP(X) \
 	if ((X) < (const char *) load_addr) (X) += load_addr
 # define NO_EARLY_SEND_STDERR
diff --git a/ldso/include/dl-syscall.h b/ldso/include/dl-syscall.h
index 547dad1..4e61a95 100644
--- a/ldso/include/dl-syscall.h
+++ b/ldso/include/dl-syscall.h
@@ -48,9 +48,18 @@ static __always_inline _syscall1(void, _dl_exit, int, status)
 #define __NR__dl_close __NR_close
 static __always_inline _syscall1(int, _dl_close, int, fd)
 
+#if defined(__NR_openat) && ! defined(__NR_open)
+static __always_inline int _dl_open(const char *fn,
+						int flags, __kernel_mode_t mode)
+{
+	return INLINE_SYSCALL(openat, 4, AT_FDCWD, fn, flags, mode);
+}
+
+#elif defined(__NR_open)
 #define __NR__dl_open __NR_open
 static __always_inline _syscall3(int, _dl_open, const char *, fn, int, flags,
                         __kernel_mode_t, mode)
+#endif
 
 #define __NR__dl_write __NR_write
 static __always_inline _syscall3(unsigned long, _dl_write, int, fd,
@@ -64,12 +73,85 @@ static __always_inline _syscall3(unsigned long, _dl_read, int, fd,
 static __always_inline _syscall3(int, _dl_mprotect, const void *, addr,
                         unsigned long, len, int, prot)
 
+#if defined(__NR_fstatat64) && ! defined(__NR_stat)
+static __always_inline int _dl_stat(const char *file_name,
+                        struct stat * buf)
+{
+	int ret;
+	struct kernel_stat64 kbuf;
+	size_t n;
+	register unsigned char *p;
+
+	ret = INLINE_SYSCALL(fstatat64, 4, AT_FDCWD, file_name, &kbuf, 0);
+
+	if (ret == 0) {
+		/* We have no libc so we need to implement our own memset */
+		n = sizeof(*buf);
+		p = buf;
+		while(n) {
+			*p++ = 0;
+			--n;
+		}
+		buf->st_dev = kbuf.st_dev;
+		buf->st_ino = kbuf.st_ino;
+		buf->st_mode = kbuf.st_mode;
+		buf->st_nlink = kbuf.st_nlink;
+		buf->st_uid = kbuf.st_uid;
+		buf->st_gid = kbuf.st_gid;
+		buf->st_rdev = kbuf.st_rdev;
+		buf->st_size = kbuf.st_size;
+		buf->st_blksize = kbuf.st_blksize;
+		buf->st_blocks = kbuf.st_blocks;
+		buf->st_atim = kbuf.st_atim;
+		buf->st_mtim = kbuf.st_mtim;
+		buf->st_ctim = kbuf.st_ctim;
+	}
+	return ret;
+}
+#elif defined(__NR_stat)
 #define __NR__dl_stat __NR_stat
 static __always_inline _syscall2(int, _dl_stat, const char *, file_name,
                         struct stat *, buf)
+#endif
 
+#if defined(__NR_fstat64) && ! defined(__NR_fstat)
+static __always_inline int _dl_fstat(int fd, struct stat *buf)
+{
+	int result;
+	struct kernel_stat64 kbuf;
+	size_t n;
+	register unsigned char *p;
+
+	result = INLINE_SYSCALL(fstat64, 2, fd, &kbuf);
+
+	if (result == 0) {
+		/* We have no libc so we need to implement our own memset */
+		n = sizeof(*buf);
+		p = buf;
+		while(n) {
+			*p++ = 0;
+			--n;
+		}
+		buf->st_dev = kbuf.st_dev;
+		buf->st_ino = kbuf.st_ino;
+		buf->st_mode = kbuf.st_mode;
+		buf->st_nlink = kbuf.st_nlink;
+		buf->st_uid = kbuf.st_uid;
+		buf->st_gid = kbuf.st_gid;
+		buf->st_rdev = kbuf.st_rdev;
+		buf->st_size = kbuf.st_size;
+		buf->st_blksize = kbuf.st_blksize;
+		buf->st_blocks = kbuf.st_blocks;
+		buf->st_atim = kbuf.st_atim;
+		buf->st_mtim = kbuf.st_mtim;
+		buf->st_ctim = kbuf.st_ctim;
+	}
+	return result;
+}
+#elif defined(__NR_fstat)
 #define __NR__dl_fstat __NR_fstat
 static __always_inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf)
+#endif
 
 #define __NR__dl_munmap __NR_munmap
 static __always_inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length)
@@ -104,9 +186,15 @@ static __always_inline _syscall0(gid_t, _dl_getegid)
 #define __NR__dl_getpid __NR_getpid
 static __always_inline _syscall0(gid_t, _dl_getpid)
 
+#if defined(__NR_readlinkat) && ! defined(__NR_readlink)
+#define __NR__dl_readlink __NR_readlinkat
+static __always_inline _syscall4(int, _dl_readlink, int, id, const char *, path,
+						char *, buf, size_t, bufsiz)
+#elif defined(__NR_readlink)
 #define __NR__dl_readlink __NR_readlink
 static __always_inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
                         size_t, bufsiz)
+#endif
 
 #ifdef __NR_pread64
 #define __NR___syscall_pread __NR_pread64
diff --git a/ldso/include/ldso.h b/ldso/include/ldso.h
index 6f3b728..cfd60a3 100644
--- a/ldso/include/ldso.h
+++ b/ldso/include/ldso.h
@@ -30,6 +30,10 @@
 #include <stddef.h> /* for ptrdiff_t */
 #include <stdbool.h>
 #define _FCNTL_H
+/* We need this if arch has only new syscalls defined */
+#ifndef AT_FDCWD
+#define AT_FDCWD -100
+#endif /* AT_FDCWD */
 #include <bits/fcntl.h>
 #include <bits/wordsize.h>
 /* Pull in the arch specific type information */
diff --git a/ldso/ldso/metag/dl-debug.h b/ldso/ldso/metag/dl-debug.h
new file mode 100644
index 0000000..c7f1257
--- /dev/null
+++ b/ldso/ldso/metag/dl-debug.h
@@ -0,0 +1,52 @@
+/*
+ * META ELF shared library loader support.
+ *
+ * Program to load an elf binary on a linux system, and run it.
+ * References to symbols in sharable libraries can be resolved
+ * by either an ELF sharable library or a linux style of shared
+ * library.
+ *
+ * Copyright (C) 2006-2012 Imagination Technologies Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static const char *_dl_reltypes_tab[] = {
+	[0]  "R_METAG_HIADDR16", "R_METAG_LOADDR16", "R_METAG_ADDR32",
+	[3]  "R_METAG_NONE", "R_METAG_RELBRANCH", "R_METAG_GETSETOFF",
+	[6]  "R_METAG_REG32OP1", "R_METAG_REG32OP2", "R_METAG_REG32OP3",
+	[9]  "R_METAG_REG16OP1", "R_METAG_REG16OP2", "R_METAG_REG16OP3",
+	[12] "R_METAG_REG32OP4", "R_METAG_HIOG", "R_METAG_LOOG",
+	[30] "R_METAG_GNU_VTINHERIT", "R_METAG_GNU_VTENTRY",
+	[32] "R_METAG_HI16_GOTOFF", "R_METAG_LO16_GOTOFF",
+	[34] "R_METAG_GETSET_GOTOFF", "R_METAG_GETSET_GOT",
+	[36] "R_METAG_HI16_GOTPC", "R_METAG_LO16_GOTPC",
+	[38] "R_METAG_HI16_PLT", "R_METAG_LO16_PLT",
+	[40] "R_METAG_RELBRANCH_PLT", "R_METAG_GOTOFF",
+	[42] "R_METAG_PLT", "R_METAG_COPY", "R_METAG_JMP_SLOT",
+	[45] "R_METAG_RELATIVE", "R_METAG_GLOB_DAT", "R_METAG_TLS_GD",
+	[48] "R_METAG_TLS_LDM", "R_METAG_TLS_LDO_HI16", "R_METAG_TLS_LDO_LO16",
+	[51] "R_METAG_TLS_LDO", "R_METAG_TLS_IE", "R_METAG_TLS_IENONPIC",
+	[54] "R_METAG_TLS_IENONPIC_HI16", "R_METAG_TLS_IENONPIC_LO16",
+	[56] "R_METAG_TLS_TPOFF", "R_METAG_TLS_DTPMOD", "R_METAG_TLS_DTPOFF",
+	[59] "R_METAG_TLS_LE", "R_METAG_TLS_LE_HI16", "R_METAG_TLS_LE_LO16"
+};
diff --git a/ldso/ldso/metag/dl-inlines.h b/ldso/ldso/metag/dl-inlines.h
new file mode 100644
index 0000000..f51d402
--- /dev/null
+++ b/ldso/ldso/metag/dl-inlines.h
@@ -0,0 +1,34 @@
+
+static __always_inline int
+__dl_is_special_segment (Elf32_Ehdr *epnt,
+			 Elf32_Phdr *ppnt)
+{
+  if (ppnt->p_type != PT_LOAD &&
+      ppnt->p_type != PT_DYNAMIC)
+    return 0;
+
+  if (ppnt->p_vaddr >= 0x80000000 &&
+      ppnt->p_vaddr < 0x82060000)
+    return 1;
+
+  if (ppnt->p_vaddr >= 0xe0200000 &&
+      ppnt->p_vaddr < 0xe0260000)
+    return 1;
+
+  return 0;
+}
+
+static __always_inline char *
+__dl_map_segment (Elf32_Ehdr *epnt,
+		  Elf32_Phdr *ppnt,
+		  int infile,
+		  int flags)
+{
+  char *addr = (char *)ppnt->p_vaddr;
+
+  if (_DL_PREAD (infile, addr, ppnt->p_filesz, ppnt->p_offset) != ppnt->p_filesz) {
+    return 0;
+  }
+
+  return addr;
+}
diff --git a/ldso/ldso/metag/dl-startup.h b/ldso/ldso/metag/dl-startup.h
new file mode 100644
index 0000000..a7191c8
--- /dev/null
+++ b/ldso/ldso/metag/dl-startup.h
@@ -0,0 +1,62 @@
+/*
+ * Architecture specific code used by dl-startup.c
+ */
+
+/* This code fixes the stack pointer so that the dynamic linker
+ * can find argc, argv and auxvt (Auxillary Vector Table).  */
+
+__asm__ (
+"	.text\n"
+"	.global __start\n"
+"	.type   __start,@function\n"
+"	.global _start\n"
+"	.type   _start,@function\n"
+"_start:\n"
+"__start:\n"
+"       MSETL   [A0StP++],D0Ar4,D0Ar2\n"
+"       MOV     D1Ar1,D0Ar2\n"
+"       CALLR   D1RtP,__dl_start\n"
+"       GETL    D0Ar2,D1Ar1,[A0StP+#-(1*8)]\n"
+"       GETL    D0Ar4,D1Ar3,[A0StP+#-(2*8)]\n"
+"       ADDT    A1LbP,CPC1,#HI(__GLOBAL_OFFSET_TABLE__)\n"
+"       ADD     A1LbP,A1LbP,#LO(__GLOBAL_OFFSET_TABLE__+4)\n"
+"       ADDT    A1LbP,A1LbP,#HI(__dl_fini@GOTOFF)\n"
+"       ADD     A1LbP,A1LbP,#LO(__dl_fini@GOTOFF)\n"
+"       MOV     D0Ar4, A1LbP\n"
+"       SUB     A0StP,A0StP,#(2*8)\n"
+"       MOV     PC,D0Re0\n"
+"	.size __start,.-__start\n"
+"	.previous\n"
+);
+
+
+/* Get a pointer to the argv array.  On many platforms this can be just
+ * the address if the first argument, on other platforms we need to
+ * do something a little more subtle here.  */
+#define GET_ARGV(ARGVP, ARGS) ARGVP = (((unsigned long *) ARGS))
+
+
+/* Handle relocation of the symbols in the dynamic loader. */
+static inline
+void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
+	unsigned long symbol_addr, unsigned long load_addr, Elf32_Sym *symtab)
+{
+	switch (ELF32_R_TYPE(rpnt->r_info)) {
+		case R_METAG_GLOB_DAT:
+		case R_METAG_JMP_SLOT:
+		case R_METAG_ADDR32:
+			*reloc_addr = symbol_addr;
+			break;
+		case R_METAG_RELATIVE:
+			*reloc_addr = load_addr + rpnt->r_addend;
+			break;
+		case R_METAG_RELBRANCH:
+			*reloc_addr = symbol_addr + rpnt->r_addend - *reloc_addr - 4;
+			break;
+		case R_METAG_NONE:
+			break;
+		default:
+			_dl_exit(1);
+			break;
+	}
+}
diff --git a/ldso/ldso/metag/dl-syscalls.h b/ldso/ldso/metag/dl-syscalls.h
new file mode 100644
index 0000000..8acbe5d
--- /dev/null
+++ b/ldso/ldso/metag/dl-syscalls.h
@@ -0,0 +1,13 @@
+/* We can't use the real errno in ldso, since it has not yet
+ * been dynamicly linked in yet. */
+#include "sys/syscall.h"
+extern int _dl_errno;
+#undef __set_errno
+#define __set_errno(X) {(_dl_errno) = (X);}
+
+#ifndef __NR_getuid
+#define __NR_getuid __NR_getuid32
+#endif
+#ifndef __NR_getgid
+#define __NR_getgid __NR_getgid32
+#endif
diff --git a/ldso/ldso/metag/dl-sysdep.h b/ldso/ldso/metag/dl-sysdep.h
new file mode 100644
index 0000000..34f6762
--- /dev/null
+++ b/ldso/ldso/metag/dl-sysdep.h
@@ -0,0 +1,115 @@
+/* META can never use Elf32_Rel relocations. */
+#define ELF_USES_RELOCA
+
+#include <elf.h>
+
+/* Initialization sequence for the GOT.  */
+#define INIT_GOT(GOT_BASE,MODULE)				\
+{								\
+	GOT_BASE[1] = (unsigned long) MODULE; 			\
+	GOT_BASE[2] = (unsigned long) _dl_linux_resolve; 	\
+}
+
+/* Maximum unsigned GOT [GS]ETD offset size, ie. 2^(11+2). */
+#define GOT_REG_OFFSET 0x2000
+
+/* Defined some magic numbers that this ld.so should accept. */
+#define MAGIC1 EM_METAG
+#undef  MAGIC2
+#define ELF_TARGET "META"
+
+/* Need bootstrap relocations */
+#define ARCH_NEEDS_BOOTSTRAP_RELOCS
+
+struct elf_resolve;
+extern unsigned long _dl_linux_resolver(struct elf_resolve *tpnt, int reloc_entry);
+
+/* Variable page size. */
+#define ADDR_ALIGN (_dl_pagesize - 1)
+#define PAGE_ALIGN (~ADDR_ALIGN)
+#define OFFS_ALIGN (PAGE_ALIGN & ~(1ul << (sizeof(_dl_pagesize) * 8 - 1)))
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or
+   TLS variable, so undefined references should not be allowed to
+   define the value.
+
+   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc.  */
+#define elf_machine_type_class(type)                                 \
+  ((((type) == R_METAG_JMP_SLOT || (type) == R_METAG_TLS_DTPMOD      \
+     || (type) == R_METAG_TLS_DTPOFF || (type) == R_METAG_TLS_TPOFF) \
+     * ELF_RTYPE_CLASS_PLT)                                          \
+     | (((type) == R_METAG_COPY) * ELF_RTYPE_CLASS_COPY))
+
+static inline Elf32_Addr
+elf_machine_dynamic(Elf32_Ehdr *header)
+{
+	Elf32_Addr *got;
+
+	__asm__ ("MOV %0,A1LbP" : "=r" (got));
+
+	if (header->e_ident[EI_ABIVERSION] >= 1) {
+		/* GOT register offset was introduced with ABI v1 */
+		got = (Elf32_Addr*)((void*)got - GOT_REG_OFFSET);
+	}
+	return *got;
+}
+
+#define DL_BOOT_COMPUTE_GOT(GOT) \
+    ((GOT) = elf_machine_dynamic(header))
+
+static inline Elf32_Addr
+elf_machine_load_address(void)
+{
+	Elf32_Addr addr = 0;
+	__asm__ ("MOV  D0Re0,A1LbP\n"
+		 "ADDT D0Re0,D0Re0,#HI(__dl_start@GOTOFF)\n"
+		 "ADD  D0Re0,D0Re0,#LO(__dl_start@GOTOFF)\n"
+		 "MOVT D0Ar6,#HI(__dl_start)\n"
+		 "ADD  D0Ar6,D0Ar6,#LO(__dl_start)\n"
+		 "SUB  %0,D0Re0,D0Ar6\n"
+		 : "=r" (addr) : : "D0Re0", "D0Ar6");
+	return addr;
+}
+
+static inline void
+elf_machine_relative(Elf32_Addr load_off, const Elf32_Addr rel_addr,
+                     Elf32_Word relative_count)
+{
+	Elf32_Rela *rpnt = (void *)rel_addr;
+
+	--rpnt;
+	do {
+		Elf32_Addr *const reloc_addr =
+			(void *)(load_off + (++rpnt)->r_offset);
+
+		*reloc_addr =  load_off + rpnt->r_addend;
+	} while (--relative_count);
+}
+
+#define DL_MALLOC_ALIGN 8
+
+#define HAVE_DL_INLINES_H
+
+#define DL_IS_SPECIAL_SEGMENT(EPNT, PPNT) \
+  __dl_is_special_segment(EPNT, PPNT)
+#define DL_MAP_SEGMENT(EPNT, PPNT, INFILE, FLAGS) \
+  __dl_map_segment (EPNT, PPNT, INFILE, FLAGS)
+
+#define DL_CHECK_LIB_TYPE(epnt, piclib, _dl_progname, libname) \
+do \
+{ \
+  ElfW(Phdr) *ppnt_; \
+  char *header_ = (char *)epnt;				   \
+  ppnt_ = (ElfW(Phdr) *)(intptr_t) & header_[epnt->e_phoff]; \
+  if (ppnt_->p_vaddr >= 0x80000000 && \
+      ppnt_->p_vaddr < 0x82060000) \
+    (piclib) = 2; \
+  if (ppnt_->p_vaddr >= 0xe0200000 && \
+      ppnt_->p_vaddr < 0xe0260000) \
+    (piclib) = 2; \
+} \
+while (0)
+
+#define _DL_PREAD(FD, BUF, SIZE, OFFSET) \
+  (_dl_pread((FD), (BUF), (SIZE), (OFFSET)))
diff --git a/ldso/ldso/metag/elfinterp.c b/ldso/ldso/metag/elfinterp.c
new file mode 100644
index 0000000..71febe0
--- /dev/null
+++ b/ldso/ldso/metag/elfinterp.c
@@ -0,0 +1,337 @@
+/*
+ * META ELF shared library loader support.
+ *
+ * Program to load an elf binary on a linux system, and run it.
+ * References to symbols in sharable libraries can be resolved
+ * by either an ELF sharable library or a linux style of shared
+ * library.
+ *
+ * Copyright (C) 2006-2012 Imagination Technologies Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "ldso.h"
+
+/* Defined in resolve.S. */
+extern int _dl_linux_resolve(void);
+
+static inline unsigned long __get_unaligned_reloc(unsigned long *addr)
+{
+	char *rel_addr = (char *)addr;
+	unsigned long val;
+
+	val = *rel_addr++ & 0xff;
+	val |= (*rel_addr++ << 8) & 0x0000ff00;
+	val |= (*rel_addr++ << 16) & 0x00ff0000;
+	val |= (*rel_addr++ << 24) & 0xff000000;
+
+	return val;
+}
+
+static inline void __put_unaligned_reloc(unsigned long *addr,
+					 unsigned long val)
+{
+	char *rel_addr = (char *)addr;
+
+	*rel_addr++ = (val & 0x000000ff);
+	*rel_addr++ = ((val & 0x0000ff00) >> 8);
+	*rel_addr++ = ((val & 0x00ff0000) >> 16);
+	*rel_addr++ = ((val & 0xff000000) >> 24);
+}
+
+unsigned long
+_dl_linux_resolver(struct elf_resolve *tpnt, int reloc_entry)
+{
+	int symtab_index;
+	char *strtab;
+	char *symname;
+	char *new_addr;
+	char *rel_addr;
+	char **got_addr;
+	ElfW(Sym) *symtab;
+	ELF_RELOC *this_reloc;
+	unsigned long instr_addr;
+
+	rel_addr = (char *)tpnt->dynamic_info[DT_JMPREL];
+
+	this_reloc = (ELF_RELOC *)(intptr_t)(rel_addr + reloc_entry);
+	symtab_index = ELF_R_SYM(this_reloc->r_info);
+
+	symtab = (ElfW(Sym) *)(intptr_t)tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+	symname = strtab + symtab[symtab_index].st_name;
+
+	/* Address of the jump instruction to fix up. */
+	instr_addr = ((unsigned long)this_reloc->r_offset +
+		      (unsigned long)tpnt->loadaddr);
+	got_addr = (char **)instr_addr;
+
+	/* Get the address of the GOT entry. */
+	new_addr = _dl_find_hash(symname, &_dl_loaded_modules->symbol_scope, tpnt,
+			ELF_RTYPE_CLASS_PLT, NULL);
+	if (unlikely(!new_addr)) {
+		_dl_dprintf(2, "%s: Can't resolve symbol '%s'\n",
+			    _dl_progname, symname);
+		_dl_exit(1);
+	}
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_bindings) {
+		_dl_dprintf(_dl_debug_file, "\nresolve function: %s", symname);
+		if (_dl_debug_detail)
+			_dl_dprintf(_dl_debug_file,
+				    "\n\tpatched: %x ==> %x @ %x\n",
+				    *got_addr, new_addr, got_addr);
+	}
+	if (!_dl_debug_nofixups) {
+		*got_addr = new_addr;
+	}
+#else
+	*got_addr = new_addr;
+#endif
+
+	return (unsigned long)new_addr;
+}
+
+static int
+_dl_parse(struct elf_resolve *tpnt, struct r_scope_elem *scope,
+	  unsigned long rel_addr, unsigned long rel_size,
+	  int (*reloc_fnc)(struct elf_resolve *tpnt, struct r_scope_elem *scope,
+			   ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab))
+{
+	int symtab_index;
+	unsigned int i;
+	char *strtab;
+	ElfW(Sym) *symtab;
+	ELF_RELOC *rpnt;
+
+	/* Parse the relocation information. */
+	rpnt = (ELF_RELOC *)(intptr_t)rel_addr;
+	rel_size /= sizeof(ELF_RELOC);
+
+	symtab = (ElfW(Sym) *)(intptr_t)tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+
+	for (i = 0; i < rel_size; i++, rpnt++) {
+		int res;
+
+		symtab_index = ELF_R_SYM(rpnt->r_info);
+
+		debug_sym(symtab, strtab, symtab_index);
+		debug_reloc(symtab, strtab, rpnt);
+
+		/* Pass over to actual relocation function. */
+		res = reloc_fnc(tpnt, scope, rpnt, symtab, strtab);
+
+		if (res == 0)
+			continue;
+
+		_dl_dprintf(2, "\n%s: ", _dl_progname);
+
+		if (symtab_index)
+			_dl_dprintf(2, "symbol '%s': ",
+				    strtab + symtab[symtab_index].st_name);
+
+		if (unlikely(res < 0)) {
+			int reloc_type = ELF_R_TYPE(rpnt->r_info);
+
+#if defined (__SUPPORT_LD_DEBUG__)
+			_dl_dprintf(2, "can't handle reloc type %s\n",
+				    _dl_reltypes(reloc_type));
+#else
+			_dl_dprintf(2, "can't handle reloc type %x\n",
+				    reloc_type);
+#endif
+			_dl_exit(-res);
+		} else if (unlikely(res > 0)) {
+			_dl_dprintf(2, "can't resolve symbol\n");
+			return res;
+		}
+	}
+
+	return 0;
+}
+
+static int
+_dl_do_reloc(struct elf_resolve *tpnt, struct r_scope_elem *scope,
+	     ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab)
+{
+	int reloc_type;
+	int symtab_index;
+	char *symname = NULL;
+	unsigned long *reloc_addr;
+	unsigned long symbol_addr;
+#if defined (__SUPPORT_LD_DEBUG__)
+	unsigned long old_val = 0;
+#endif
+	struct elf_resolve *tls_tpnt = NULL;
+	struct symbol_ref sym_ref;
+
+	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
+	reloc_type = ELF_R_TYPE(rpnt->r_info);
+	symtab_index = ELF_R_SYM(rpnt->r_info);
+	symbol_addr = 0;
+	sym_ref.sym = &symtab[symtab_index];
+	sym_ref.tpnt = NULL;
+
+	if (symtab_index) {
+		symname = strtab + symtab[symtab_index].st_name;
+		symbol_addr = (unsigned long)_dl_find_hash(symname, scope, tpnt,
+							   elf_machine_type_class(reloc_type), &sym_ref);
+
+		if (!symbol_addr
+		    && ELF_ST_TYPE(symtab[symtab_index].st_info) != STT_TLS
+		    && ELF_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
+			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n",
+				    _dl_progname, symname);
+			return 1;
+		};
+		if (_dl_trace_prelink) {
+			_dl_debug_lookup(symname, tpnt, &symtab[symtab_index],
+				&sym_ref, elf_machine_type_class(reloc_type));
+		}
+		tls_tpnt = sym_ref.tpnt;
+	}
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (reloc_type != R_METAG_NONE)
+		old_val = __get_unaligned_reloc(reloc_addr);
+#endif
+
+#if defined USE_TLS && USE_TLS
+	/* In case of a TLS reloc, tls_tpnt NULL means we have an 'anonymous'
+	   symbol.  This is the case for a static tls variable, so the lookup
+	   module is just that one is referencing the tls variable. */
+	if (!tls_tpnt)
+		tls_tpnt = tpnt;
+#endif
+	switch (reloc_type) {
+		case R_METAG_NONE:
+			break;
+		case R_METAG_GLOB_DAT:
+		case R_METAG_JMP_SLOT:
+		case R_METAG_ADDR32:
+			__put_unaligned_reloc(reloc_addr,
+					      symbol_addr + rpnt->r_addend);
+			break;
+		case R_METAG_COPY:
+#if defined (__SUPPORT_LD_DEBUG__)
+			if (_dl_debug_move)
+				_dl_dprintf(_dl_debug_file,
+					    "\t%s move %d bytes from %x to %x\n",
+					    symname, symtab[symtab_index].st_size,
+					    symbol_addr + rpnt->r_addend,
+					    reloc_addr);
+#endif
+
+			_dl_memcpy((char *)reloc_addr,
+				   (char *)symbol_addr + rpnt->r_addend,
+				   symtab[symtab_index].st_size);
+			break;
+		case R_METAG_RELATIVE:
+			__put_unaligned_reloc(reloc_addr,
+					      (unsigned long)tpnt->loadaddr +
+					      rpnt->r_addend);
+			break;
+#if defined USE_TLS && USE_TLS
+		case R_METAG_TLS_DTPMOD:
+			*reloc_addr = tls_tpnt->l_tls_modid;
+			break;
+		case R_METAG_TLS_DTPOFF:
+			*reloc_addr = symbol_addr;
+			break;
+		case R_METAG_TLS_TPOFF:
+			CHECK_STATIC_TLS ((struct link_map *) tls_tpnt);
+			*reloc_addr = tls_tpnt->l_tls_offset + symbol_addr + rpnt->r_addend;
+			break;
+#endif
+		default:
+			return -1;	/* Calls _dl_exit(1). */
+	}
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail && reloc_type != R_METAG_NONE) {
+		unsigned long new_val = __get_unaligned_reloc(reloc_addr);
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
+			    old_val, new_val, reloc_addr);
+	}
+#endif
+
+	return 0;
+}
+
+static int
+_dl_do_lazy_reloc(struct elf_resolve *tpnt, struct r_scope_elem *scope,
+		  ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab)
+{
+	int reloc_type;
+	unsigned long *reloc_addr;
+#if defined (__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+
+	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
+	reloc_type = ELF_R_TYPE(rpnt->r_info);
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	old_val = *reloc_addr;
+#endif
+
+	switch (reloc_type) {
+		case R_METAG_NONE:
+			break;
+		case R_METAG_JMP_SLOT:
+			*reloc_addr += (unsigned long)tpnt->loadaddr;
+			break;
+		default:
+			return -1;	/* Calls _dl_exit(1). */
+	}
+
+#if defined (__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
+			    old_val, *reloc_addr, reloc_addr);
+#endif
+
+	return 0;
+}
+
+/* External interface to the generic part of the dynamic linker. */
+
+void
+_dl_parse_lazy_relocation_information(struct dyn_elf *rpnt,
+				      unsigned long rel_addr,
+				      unsigned long rel_size)
+{
+	_dl_parse(rpnt->dyn, NULL, rel_addr, rel_size, _dl_do_lazy_reloc);
+}
+
+int
+_dl_parse_relocation_information(struct dyn_elf *rpnt,
+				 struct r_scope_elem *scope,
+				 unsigned long rel_addr,
+				 unsigned long rel_size)
+{
+	return _dl_parse(rpnt->dyn, scope, rel_addr,
+			 rel_size, _dl_do_reloc);
+}
diff --git a/ldso/ldso/metag/metag_load_tp.S b/ldso/ldso/metag/metag_load_tp.S
new file mode 100644
index 0000000..d761fc0
--- /dev/null
+++ b/ldso/ldso/metag/metag_load_tp.S
@@ -0,0 +1,50 @@
+/* Copyright (C) 2006-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <features.h>
+
+#ifdef __UCLIBC_HAS_THREADS_NATIVE__
+
+#include <sysdep.h>
+
+	.text
+	.global ___metag_load_tp
+	.type   ___metag_load_tp,@function
+
+___metag_load_tp:
+	MOVT	D1Ar1,#HI(0x6ffff000)
+	JUMP	D1Ar1,#LO(0x6ffff000)
+	.size   ___metag_load_tp,.-___metag_load_tp
+
+#endif /* __UCLIBC_HAS_THREADS_NATIVE__ */
diff --git a/ldso/ldso/metag/resolve.S b/ldso/ldso/metag/resolve.S
new file mode 100644
index 0000000..9875873
--- /dev/null
+++ b/ldso/ldso/metag/resolve.S
@@ -0,0 +1,45 @@
+/*
+ * This function is _not_ called directly.  It is jumped to (so no return
+ * address is on the stack) when attempting to use a symbol that has not yet
+ * been resolved.  The first time a jump symbol (such as a function call inside
+ * a shared library) is used (before it gets resolved) it will jump here to
+ * _dl_linux_resolve.  When we get called the stack looks like this:
+ *	reloc_entry
+ *	tpnt
+ *
+ * This function saves all the registers then makes the function call
+ * _dl_linux_resolver(tpnt, reloc_entry).  _dl_linux_resolver() figures out
+ * where the jump symbol is _really_ supposed to have jumped to and returns
+ * that to us.  Once we have that, we overwrite tpnt with this fixed up
+ * address. We then clean up after ourselves, put all the registers back how we
+ * found them, then we jump to the fixed up address, which is where the jump
+ * symbol that got us here really wanted to jump to in the first place.
+ *  -Erik Andersen
+ */
+
+	.text
+	.global __dl_linux_resolve
+	.type   __dl_linux_resolve,@function
+
+__dl_linux_resolve:
+	!! Save registers on the stack. Do we need to save any more here?
+	MSETL [A0StP++],D0Ar6,D0Ar4,D0Ar2,D0FrT
+	SETL  [A0StP++],A0FrP,A1LbP
+	!! Get the args for _dl_linux_resolver off the stack
+	GETL  D0Re0,D1Re0,[A0StP+#-(6*8)]
+	GETD  D1Ar1,[D0Re0]
+	MOV   D0Ar2,D1Re0
+	!! Multiply plt_index by sizeof(Elf32_Rela)
+	MULW  D0Ar2,D0Ar2,#12
+	!! Call the resolver
+	CALLR D1RtP,__dl_linux_resolver
+	!! Restore the registers from the stack
+	SUB   A0.2,A0StP,#(1*8)
+	GETL  A0FrP,A1LbP,[A0.2]
+	SUB   A0.2,A0.2,#(4*8)
+	MGETL D0Ar6,D0Ar4,D0Ar2,D0FrT,[A0.2]
+	!! Also take into account args pushed by PLT
+	SUB   A0StP,A0StP,#(6*8)
+	!! Jump to the resolved address
+	MOV   PC,D0Re0
+	.size __dl_linux_resolve, .-__dl_linux_resolve
diff --git a/libc/misc/statfs/fstatfs64.c b/libc/misc/statfs/fstatfs64.c
index 27bb8d6..0cb710f 100644
--- a/libc/misc/statfs/fstatfs64.c
+++ b/libc/misc/statfs/fstatfs64.c
@@ -23,8 +23,10 @@
 #include <string.h>
 #include <sys/statfs.h>
 #include <sys/statvfs.h>
+#include <sys/syscall.h>
 #include <stddef.h>
 
+#if defined(__NR_fstatfs)
 extern __typeof(fstatfs) __libc_fstatfs;
 
 /* Return information about the filesystem on which FD resides.  */
@@ -48,4 +50,16 @@ int fstatfs64 (int fd, struct statfs64 *buf)
 
     return 0;
 }
+#else
+/*
+ * Use the fstatfs64 system call if fstatfs is not defined
+ * This is for backwards compatibility and it should be
+ * made default in the future
+ */
+int fstatfs64(int fd, struct statfs64 *buf)
+{
+	/* Signature has 2 arguments but syscalls wants 3 */
+	return INLINE_SYSCALL(fstatfs64, 3, fd, sizeof(*buf), buf);
+}
+#endif
 libc_hidden_def(fstatfs64)
diff --git a/libc/misc/sysvipc/ipc.h b/libc/misc/sysvipc/ipc.h
index 339d136..9f664f4 100644
--- a/libc/misc/sysvipc/ipc.h
+++ b/libc/misc/sysvipc/ipc.h
@@ -9,6 +9,14 @@
 # define __IPC_64	0x0
 #endif
 
+/* New architectures don't have the OLD_IPC interface */
+#ifdef __ARCH_HAS_NO_OLD_IPC__
+#define PROCESS_IPC_CMD(cmd)
+#else
+#define PROCESS_IPC_CMD(cmd) \
+	{ int *p = &cmd; *p = (*p) | __IPC_64; }
+#endif
+
 #ifdef __NR_ipc
 
 /* The actual system call: all functions are multiplexed by this.  */
diff --git a/libc/misc/sysvipc/msgq.c b/libc/misc/sysvipc/msgq.c
index 185cd26..0523a10 100644
--- a/libc/misc/sysvipc/msgq.c
+++ b/libc/misc/sysvipc/msgq.c
@@ -18,7 +18,8 @@ static __inline__ _syscall3(int, __libc_msgctl, int, msqid, int, cmd, struct msq
 int msgctl(int msqid, int cmd, struct msqid_ds *buf)
 {
 #ifdef __NR_msgctl
-	return __libc_msgctl(msqid, cmd | __IPC_64, buf);
+	PROCESS_IPC_CMD(cmd)
+	return __libc_msgctl(msqid, cmd, buf);
 #else
     return __syscall_ipc(IPCOP_msgctl, msqid, cmd | __IPC_64, 0, buf, 0);
 #endif
diff --git a/libc/misc/sysvipc/sem.c b/libc/misc/sysvipc/sem.c
index cca4cdf..3efdd75 100644
--- a/libc/misc/sysvipc/sem.c
+++ b/libc/misc/sysvipc/sem.c
@@ -53,8 +53,10 @@ int semctl(int semid, int semnum, int cmd, ...)
     va_start (ap, cmd);
     arg = va_arg (ap, union semun);
     va_end (ap);
+
 #ifdef __NR_semctl
-    return __semctl(semid, semnum, cmd | __IPC_64, arg.__pad);
+    PROCESS_IPC_CMD(cmd)
+    return __semctl(semid, semnum, cmd, arg.__pad);
 #else
     return __syscall_ipc(IPCOP_semctl, semid, semnum, cmd|__IPC_64, &arg, NULL);
 #endif
diff --git a/libc/misc/sysvipc/shm.c b/libc/misc/sysvipc/shm.c
index 27e871f..05d68f4 100644
--- a/libc/misc/sysvipc/shm.c
+++ b/libc/misc/sysvipc/shm.c
@@ -59,8 +59,10 @@ static __inline__ _syscall3(int, __libc_shmctl, int, shmid, int, cmd, struct shm
 #endif
 int shmctl(int shmid, int cmd, struct shmid_ds *buf)
 {
+
 #ifdef __NR_shmctl
-	return __libc_shmctl(shmid, cmd | __IPC_64, buf);
+	PROCESS_IPC_CMD(cmd)
+	return __libc_shmctl(shmid, cmd, buf);
 #else
     return __syscall_ipc(IPCOP_shmctl, shmid, cmd | __IPC_64, 0, buf, 0);
 #endif
diff --git a/libc/string/metag/Makefile b/libc/string/metag/Makefile
new file mode 100644
index 0000000..0a95346
--- /dev/null
+++ b/libc/string/metag/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir:=../../../
+top_builddir:=../../../
+all: objs
+include $(top_builddir)Rules.mak
+include ../Makefile.in
+include $(top_srcdir)Makerules
diff --git a/libc/string/metag/memchr.S b/libc/string/metag/memchr.S
new file mode 100644
index 0000000..50920e3
--- /dev/null
+++ b/libc/string/metag/memchr.S
@@ -0,0 +1,154 @@
+!   Copyright (C) 2008 Imagination Technologies Ltd.
+
+	.text
+	.global	_memchr
+	.type	_memchr,function
+! D0Ar6 src
+! D0Ar2 c
+! D1Ar3 n
+_memchr:
+	CMP     D1Ar3, #0
+	BEQ	$Lexit_fail
+	!! convert c to unsigned char
+	AND     D0Ar2,D0Ar2,#0xff
+	MOV	D0Ar6, D1Ar1
+	MOV	D1Ar5, D0Ar6
+	!! test alignment
+	AND	D1Ar5, D1Ar5, #7
+	CMP	D1Ar5, #0
+	BNZ	$Lunaligned_loop
+	!! length must be greater than or equal to 8 for aligned loop
+	CMP     D1Ar3, #8
+	BGE     $Laligned_setup
+$Lunaligned_loop:
+	!! get 1 char from s
+	GETB	D0Re0, [D0Ar6++]
+	!! increase alignment counter
+	ADD	D1Ar5, D1Ar5, #1
+	!! decrement n
+	SUB     D1Ar3, D1Ar3, #1
+	!! exit if we have a match
+	CMP	D0Re0, D0Ar2
+	BZ	$Lexit_success1
+	!! exit if we have hit the end of the string
+	CMP	D1Ar3, #0
+	BZ	$Lexit_fail
+	!! fall through if the buffer is aligned now
+	CMP	D1Ar5, #8
+	BNE	$Lunaligned_loop
+	!! fall through if there is more than 8 bytes left
+	CMP	D1Ar3, #8
+	BLT	$Lunaligned_loop
+$Laligned_setup:
+	!! fill the c into 4 bytes
+	MOV	D0Ar4, D0Ar2
+	LSL	D0Ar4, D0Ar4, #8
+	ADD	D0Ar4, D0Ar4, D0Ar2
+	LSL	D0Ar4, D0Ar4, #8
+	ADD	D0Ar4, D0Ar4, D0Ar2
+	LSL	D0Ar4, D0Ar4, #8
+	ADD	D0Ar4, D0Ar4, D0Ar2
+	!! divide n by 8
+	MOV	D1Ar5, D1Ar3
+	LSR	D1Ar5, D1Ar5, #3
+$Laligned_loop:
+	!! get 8 chars from s
+	GETL	D0Re0, D1Re0, [D0Ar6++]
+	!! decrement loop counter
+	SUB	D1Ar5, D1Ar5, #1
+	!! test first 4 chars
+	XOR	D0Re0, D0Re0, D0Ar4
+	!! test second 4 chars
+	MOV	D0Ar2, D1Re0
+	XOR	D1Re0, D0Ar2, D0Ar4
+	!! check for matches in the first 4 chars
+	MOV	D0Ar2, D0Re0
+	ADDT	D0Re0, D0Re0, #HI(0xfefefeff)
+	ADD	D0Re0, D0Re0, #LO(0xfefefeff)
+	XOR	D0Ar2, D0Ar2, #-1
+	AND	D0Re0, D0Re0, D0Ar2
+	ANDMT	D0Re0, D0Re0, #HI(0x80808080)
+	ANDMB	D0Re0, D0Re0, #LO(0x80808080)
+	CMP	D0Re0, #0
+	BNZ	$Lmatch_word1
+	!! check for matches in the second 4 chars
+	MOV	D1Ar1, D1Re0
+	ADDT	D1Re0, D1Re0, #HI(0xfefefeff)
+	ADD	D1Re0, D1Re0, #LO(0xfefefeff)
+	XOR	D1Ar1, D1Ar1, #-1
+	AND	D1Re0, D1Re0, D1Ar1
+	ANDMT	D1Re0, D1Re0, #HI(0x80808080)
+	ANDMB	D1Re0, D1Re0, #LO(0x80808080)
+	CMP	D1Re0, #0
+	BNZ	$Lmatch_word2
+	!! check if we have reached the end of the buffer
+	CMP	D1Ar5, #0
+	BNE	$Laligned_loop
+	!! exit if there are no chars left to check
+	AND	D1Ar3, D1Ar3, #7
+	CMP	D1Ar3, #0
+	BZ	$Lexit_fail
+	!! recover c
+	AND	D0Ar2, D0Ar4, #0xff
+$Lbyte_loop:
+	!! get 1 char from s
+	GETB	D0Re0, [D0Ar6++]
+	!! decrement n
+	SUB	D1Ar3, D1Ar3, #1
+	!! exit if we have a match
+	CMP	D0Re0, D0Ar2
+	BZ	$Lexit_success1
+	!! fall through if we have run out of chars
+	CMP	D1Ar3, #0
+	BNE	$Lbyte_loop
+
+$Lexit_fail:
+	MOV	D0Re0, #0
+	B	$Lend
+
+$Lmatch_word1:
+	!! move the match word into D1Re0
+	MOV	D1Re0, D0Re0
+	!! roll back the buffer pointer by 4 chars
+	SUB	D0Ar6, D0Ar6, #4
+$Lmatch_word2:
+	!! roll back the buffer pointer by 4 chars
+	SUB	D0Ar6, D0Ar6, #4
+	!! exit if lowest byte is 0
+	MOV	D1Ar1, D1Re0
+	AND	D1Ar1, D1Ar1, #0xff
+	CMP	D1Ar1, #0
+	BNE	$Lexit_success2
+	!! advance buffer pointer to the next char
+	ADD	D0Ar6, D0Ar6, #1
+	!! shift in the next lowest byte
+	LSR	D1Re0, D1Re0, #8
+	!! exit if lowest byte is 0
+	MOV	D1Ar1, D1Re0
+	AND	D1Ar1, D1Ar1, #0xff
+	CMP	D1Ar1, #0
+	BNE	$Lexit_success2
+	!! advance buffer pointer to the next char
+	ADD	D0Ar6, D0Ar6, #1
+	!! shift in the next lowest byte
+	LSR	D1Re0, D1Re0, #8
+	!! exit if lowest byte is 0
+	MOV	D1Ar1, D1Re0
+	AND	D1Ar1, D1Ar1, #0xff
+	CMP	D1Ar1, #0
+	BNE	$Lexit_success2
+	!! the match must be in the last byte, exit
+	ADD	D0Ar6, D0Ar6, #1
+	B	$Lexit_success2
+
+$Lexit_success1:
+	SUB	D0Ar6, D0Ar6, #1
+$Lexit_success2:
+	!! return the buffer pointer
+	MOV	D0Re0, D0Ar6
+$Lend:
+	MOV	PC, D1RtP
+
+	.size _memchr,.-_memchr
+
+libc_hidden_def(memchr)
diff --git a/libc/string/metag/memcpy.S b/libc/string/metag/memcpy.S
new file mode 100644
index 0000000..48c4d81
--- /dev/null
+++ b/libc/string/metag/memcpy.S
@@ -0,0 +1,187 @@
+!   Copyright (C) 2008-2012 Imagination Technologies Ltd.
+
+	.text
+	.global	_memcpy
+	.type	_memcpy,function
+! D1Ar1 dst
+! D0Ar2 src
+! D1Ar3 cnt
+! D0Re0 dst
+_memcpy:
+	CMP 	D1Ar3, #16
+	MOV 	A1.2, D0Ar2		! source pointer
+	MOV 	A0.2, D1Ar1		! destination pointer
+	MOV 	A0.3, D1Ar1		! for return value
+! If there are less than 16 bytes to copy use the byte copy loop
+	BGE 	$Llong_copy
+
+$Lbyte_copy:
+! Simply copy a byte at a time
+	SUBS	TXRPT, D1Ar3, #1
+	BLT	$Lend
+$Lloop_byte:
+	GETB 	D1Re0, [A1.2++]
+	SETB 	[A0.2++], D1Re0
+	BR	$Lloop_byte
+
+$Lend:
+! Finally set return value and return
+	MOV 	D0Re0, A0.3
+	MOV 	PC, D1RtP
+
+$Llong_copy:
+	ANDS 	D1Ar5, D1Ar1, #7	! test destination alignment
+	BZ	$Laligned_dst
+
+! The destination address is not 8 byte aligned. We will copy bytes from
+! the source to the destination until the remaining data has an 8 byte
+! destination address alignment (i.e we should never copy more than 7
+! bytes here).
+$Lalign_dst:
+	GETB 	D0Re0, [A1.2++]
+	ADD 	D1Ar5, D1Ar5, #1	! dest is aligned when D1Ar5 reaches #8
+	SUB 	D1Ar3, D1Ar3, #1	! decrement count of remaining bytes
+	SETB 	[A0.2++], D0Re0
+	CMP 	D1Ar5, #8
+	BNE 	$Lalign_dst
+
+! We have at least (16 - 7) = 9 bytes to copy - calculate the number of 8 byte
+! blocks, then jump to the unaligned copy loop or fall through to the aligned
+! copy loop as appropriate.
+$Laligned_dst:
+	MOV	D0Ar4, A1.2
+	LSR 	D1Ar5, D1Ar3, #3	! D1Ar5 = number of 8 byte blocks
+	ANDS 	D0Ar4, D0Ar4, #7	! test source alignment
+	BNZ 	$Lunaligned_copy	! if unaligned, use unaligned copy loop
+
+! Both source and destination are 8 byte aligned - the easy case.
+$Laligned_copy:
+	LSRS	D1Ar5, D1Ar3, #5	! D1Ar5 = number of 32 byte blocks
+	BZ	$Lbyte_copy
+	SUB	TXRPT, D1Ar5, #1
+
+$Laligned_32:
+	GETL 	D0Re0, D1Re0, [A1.2++]
+	GETL 	D0Ar6, D1Ar5, [A1.2++]
+	SETL 	[A0.2++], D0Re0, D1Re0
+	SETL 	[A0.2++], D0Ar6, D1Ar5
+	GETL 	D0Re0, D1Re0, [A1.2++]
+	GETL 	D0Ar6, D1Ar5, [A1.2++]
+	SETL 	[A0.2++], D0Re0, D1Re0
+	SETL 	[A0.2++], D0Ar6, D1Ar5
+	BR	$Laligned_32
+
+! If there are any remaining bytes use the byte copy loop, otherwise we are done
+	ANDS 	D1Ar3, D1Ar3, #0x1f
+	BNZ	$Lbyte_copy
+	B	$Lend
+
+! The destination is 8 byte aligned but the source is not, and there are 8
+! or more bytes to be copied.
+$Lunaligned_copy:
+! Adjust the source pointer (A1.2) to the 8 byte boundary before its
+! current value
+	MOV 	D0Ar4, A1.2
+	MOV 	D0Ar6, A1.2
+	ANDMB 	D0Ar4, D0Ar4, #0xfff8
+	MOV 	A1.2, D0Ar4
+! Save the number of bytes of mis-alignment in D0Ar4 for use later
+	SUBS 	D0Ar6, D0Ar6, D0Ar4
+	MOV	D0Ar4, D0Ar6
+! if there is no mis-alignment after all, use the aligned copy loop
+	BZ 	$Laligned_copy
+
+! prefetch 8 bytes
+	GETL 	D0Re0, D1Re0, [A1.2]
+
+	SUB	TXRPT, D1Ar5, #1
+
+! There are 3 mis-alignment cases to be considered. Less than 4 bytes, exactly
+! 4 bytes, and more than 4 bytes.
+	CMP 	D0Ar6, #4
+	BLT 	$Lunaligned_1_2_3	! use 1-3 byte mis-alignment loop
+	BZ 	$Lunaligned_4		! use 4 byte mis-alignment loop
+
+! The mis-alignment is more than 4 bytes
+$Lunaligned_5_6_7:
+	SUB 	D0Ar6, D0Ar6, #4
+! Calculate the bit offsets required for the shift operations necesssary
+! to align the data. 
+! D0Ar6 = bit offset, D1Ar5 = (32 - bit offset)
+	MULW 	D0Ar6, D0Ar6, #8
+	MOV	D1Ar5, #32
+	SUB	D1Ar5, D1Ar5, D0Ar6
+! Move data 4 bytes before we enter the main loop
+	MOV 	D0Re0, D1Re0
+
+$Lloop_5_6_7:
+	GETL 	D0Ar2, D1Ar1, [++A1.2]
+! form 64-bit data in D0Re0, D1Re0
+	LSR 	D0Re0, D0Re0, D0Ar6
+	MOV 	D1Re0, D0Ar2
+	LSL 	D1Re0, D1Re0, D1Ar5
+	ADD 	D0Re0, D0Re0, D1Re0
+
+	LSR 	D0Ar2, D0Ar2, D0Ar6
+	LSL 	D1Re0, D1Ar1, D1Ar5
+	ADD 	D1Re0, D1Re0, D0Ar2
+
+	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D1Ar1
+	BR	$Lloop_5_6_7
+
+	B 	$Lunaligned_end
+
+$Lunaligned_1_2_3:
+! Calculate the bit offsets required for the shift operations necesssary
+! to align the data.
+! D0Ar6 = bit offset, D1Ar5 = (32 - bit offset)
+	MULW 	D0Ar6, D0Ar6, #8
+	MOV	D1Ar5, #32
+	SUB	D1Ar5, D1Ar5, D0Ar6
+
+$Lloop_1_2_3:
+! form 64-bit data in D0Re0,D1Re0
+	LSR 	D0Re0, D0Re0, D0Ar6
+	LSL 	D1Ar1, D1Re0, D1Ar5
+	ADD 	D0Re0, D0Re0, D1Ar1
+	MOV	D0Ar2, D1Re0
+	LSR 	D0FrT, D0Ar2, D0Ar6
+	GETL 	D0Ar2, D1Ar1, [++A1.2]
+
+	MOV 	D1Re0, D0Ar2
+	LSL 	D1Re0, D1Re0, D1Ar5
+	ADD 	D1Re0, D1Re0, D0FrT
+
+	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D0Ar2
+	MOV 	D1Re0, D1Ar1
+	BR	$Lloop_1_2_3
+
+	B 	$Lunaligned_end
+
+! The 4 byte mis-alignment case - this does not require any shifting, just a
+! shuffling of registers.
+$Lunaligned_4:
+	MOV 	D0Re0, D1Re0
+$Lloop_4:
+	GETL 	D0Ar2, D1Ar1, [++A1.2]
+	MOV 	D1Re0, D0Ar2
+  	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D1Ar1
+	BR	$Lloop_4
+
+$Lunaligned_end:
+! If there are no remaining bytes to copy, we are done.
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ	$Lend
+! Re-adjust the source pointer (A1.2) back to the actual (unaligned) byte
+! address of the remaining bytes, and fall through to the byte copy loop.
+	MOV 	D0Ar6, A1.2
+	ADD 	D1Ar5, D0Ar4, D0Ar6
+	MOV 	A1.2, D1Ar5
+	B	$Lbyte_copy
+
+        .size _memcpy,.-_memcpy
+
+libc_hidden_def(memcpy)
diff --git a/libc/string/metag/memmove.S b/libc/string/metag/memmove.S
new file mode 100644
index 0000000..2039318
--- /dev/null
+++ b/libc/string/metag/memmove.S
@@ -0,0 +1,347 @@
+!   Copyright (C) 2008-2012 Imagination Technologies Ltd.
+
+	.text
+	.global	_memmove
+	.type	_memmove,function
+! D1Ar1 dst
+! D0Ar2 src
+! D1Ar3 cnt
+! D0Re0 dst
+_memmove:
+	CMP 	D1Ar3, #0
+	MOV 	D0Re0, D1Ar1
+	BZ 	$LEND2
+	MSETL 	[A0StP], D0.5, D0.6, D0.7
+	MOV 	D1Ar5, D0Ar2
+	CMP 	D1Ar1, D1Ar5
+	BLT 	$Lforwards_copy
+	SUB 	D0Ar4, D1Ar1, D1Ar3
+	ADD 	D0Ar4, D0Ar4, #1
+	CMP 	D0Ar2, D0Ar4
+	BLT 	$Lforwards_copy
+	! should copy backwards
+	MOV 	D1Re0, D0Ar2
+	! adjust pointer to the end of mem
+	ADD 	D0Ar2, D1Re0, D1Ar3
+	ADD 	D1Ar1, D1Ar1, D1Ar3
+
+	MOV 	A1.2, D0Ar2
+	MOV 	A0.2, D1Ar1
+	CMP 	D1Ar3, #8
+	BLT 	$Lbbyte_loop
+
+	MOV 	D0Ar4, D0Ar2
+	MOV 	D1Ar5, D1Ar1
+
+	! test 8 byte alignment
+	ANDS 	D1Ar5, D1Ar5, #7
+	BNE 	$Lbdest_unaligned
+
+	ANDS 	D0Ar4, D0Ar4, #7
+	BNE 	$Lbsrc_unaligned
+
+	LSR 	D1Ar5, D1Ar3, #3
+
+$Lbaligned_loop:
+	GETL 	D0Re0, D1Re0, [--A1.2]
+	SETL 	[--A0.2], D0Re0, D1Re0
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lbaligned_loop
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lbbyte_loop_exit
+$Lbbyte_loop:
+	GETB 	D1Re0, [--A1.2]
+	SETB 	[--A0.2], D1Re0
+	SUBS 	D1Ar3, D1Ar3, #1
+	BNE 	$Lbbyte_loop
+$Lbbyte_loop_exit:
+	MOV 	D0Re0, A0.2
+$LEND:
+	SUB 	A0.2, A0StP, #24
+	MGETL 	D0.5, D0.6, D0.7, [A0.2]
+	SUB 	A0StP, A0StP, #24
+$LEND2:
+	MOV 	PC, D1RtP
+
+$Lbdest_unaligned:
+	GETB 	D0Re0, [--A1.2]
+	SETB 	[--A0.2], D0Re0
+	SUBS 	D1Ar5, D1Ar5, #1
+	SUB 	D1Ar3, D1Ar3, #1
+	BNE 	$Lbdest_unaligned
+	CMP 	D1Ar3, #8
+	BLT 	$Lbbyte_loop
+$Lbsrc_unaligned:
+	LSR 	D1Ar5, D1Ar3, #3
+	! adjust A1.2
+	MOV 	D0Ar4, A1.2
+	! save original address
+	MOV 	D0Ar6, A1.2
+
+	ADD 	D0Ar4, D0Ar4, #7
+	ANDMB 	D0Ar4, D0Ar4, #0xfff8
+	! new address is the 8-byte aligned one above the original
+	MOV 	A1.2, D0Ar4
+
+	! A0.2 dst 64-bit is aligned
+	! measure the gap size
+	SUB 	D0Ar6, D0Ar4, D0Ar6
+	MOVS 	D0Ar4, D0Ar6
+	! keep this information for the later adjustment
+	! both aligned
+	BZ 	$Lbaligned_loop
+
+	! prefetch
+	GETL 	D0Re0, D1Re0, [--A1.2]
+
+	CMP 	D0Ar6, #4
+	BLT 	$Lbunaligned_1_2_3
+	! 32-bit aligned
+	BZ 	$Lbaligned_4
+
+	SUB 	D0Ar6, D0Ar6, #4
+	! D1.6 stores the gap size in bits
+	MULW 	D1.6, D0Ar6, #8
+	MOV 	D0.6, #32
+	! D0.6 stores the complement of the gap size
+	SUB 	D0.6, D0.6, D1.6
+
+$Lbunaligned_5_6_7:
+	GETL 	D0.7, D1.7, [--A1.2]
+	! form 64-bit data in D0Re0, D1Re0
+	MOV 	D1Re0, D0Re0
+	! D1Re0 << gap-size
+	LSL 	D1Re0, D1Re0, D1.6
+	MOV 	D0Re0, D1.7
+	! D0Re0 >> complement
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D1.5, D0Re0
+	! combine the both
+	ADD 	D1Re0, D1Re0, D1.5
+
+	MOV 	D1.5, D1.7
+	LSL 	D1.5, D1.5, D1.6
+	MOV 	D0Re0, D0.7
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D0.5, D1.5
+	ADD 	D0Re0, D0Re0, D0.5
+
+	SETL 	[--A0.2], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lbunaligned_5_6_7
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lbbyte_loop_exit
+	! Adjust A1.2
+	! A1.2 <- A1.2 +8 - gapsize
+	ADD 	A1.2, A1.2, #8
+	SUB 	A1.2, A1.2, D0Ar4
+	B 	$Lbbyte_loop
+
+$Lbunaligned_1_2_3:
+	MULW 	D1.6, D0Ar6, #8
+	MOV 	D0.6, #32
+	SUB 	D0.6, D0.6, D1.6
+
+$Lbunaligned_1_2_3_loop:
+	GETL 	D0.7, D1.7, [--A1.2]
+	! form 64-bit data in D0Re0, D1Re0
+	LSL 	D1Re0, D1Re0, D1.6
+	! save D0Re0 for later use
+	MOV 	D0.5, D0Re0
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D1.5, D0Re0
+	ADD 	D1Re0, D1Re0, D1.5
+
+	! orignal data in D0Re0
+	MOV 	D1.5, D0.5
+	LSL 	D1.5, D1.5, D1.6
+	MOV 	D0Re0, D1.7
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D0.5, D1.5
+	ADD 	D0Re0, D0Re0, D0.5
+
+	SETL 	[--A0.2], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lbunaligned_1_2_3_loop
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lbbyte_loop_exit
+	! Adjust A1.2
+	ADD 	A1.2, A1.2, #8
+	SUB 	A1.2, A1.2, D0Ar4
+	B 	$Lbbyte_loop
+
+$Lbaligned_4:
+	GETL 	D0.7, D1.7, [--A1.2]
+	MOV 	D1Re0, D0Re0
+	MOV 	D0Re0, D1.7
+	SETL 	[--A0.2], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lbaligned_4
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lbbyte_loop_exit
+	! Adjust A1.2
+	ADD 	A1.2, A1.2, #8
+	SUB 	A1.2, A1.2, D0Ar4
+	B 	$Lbbyte_loop
+
+$Lforwards_copy:
+	MOV 	A1.2, D0Ar2
+	MOV 	A0.2, D1Ar1
+	CMP 	D1Ar3, #8
+	BLT 	$Lfbyte_loop
+
+	MOV 	D0Ar4, D0Ar2
+	MOV 	D1Ar5, D1Ar1
+
+	ANDS 	D1Ar5, D1Ar5, #7
+	BNE 	$Lfdest_unaligned
+
+	ANDS 	D0Ar4, D0Ar4, #7
+	BNE 	$Lfsrc_unaligned
+
+	LSR 	D1Ar5, D1Ar3, #3
+
+$Lfaligned_loop:
+	GETL 	D0Re0, D1Re0, [A1.2++]
+	SUBS 	D1Ar5, D1Ar5, #1
+	SETL 	[A0.2++], D0Re0, D1Re0
+	BNE 	$Lfaligned_loop
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lfbyte_loop_exit
+$Lfbyte_loop:
+	GETB 	D1Re0, [A1.2++]
+	SETB 	[A0.2++], D1Re0
+	SUBS 	D1Ar3, D1Ar3, #1
+	BNE 	$Lfbyte_loop
+$Lfbyte_loop_exit:
+	MOV 	D0Re0, D1Ar1
+	B 	$LEND
+
+$Lfdest_unaligned:
+	GETB 	D0Re0, [A1.2++]
+	ADD 	D1Ar5, D1Ar5, #1
+	SUB 	D1Ar3, D1Ar3, #1
+	SETB 	[A0.2++], D0Re0
+	CMP 	D1Ar5, #8
+	BNE 	$Lfdest_unaligned
+	CMP 	D1Ar3, #8
+	BLT 	$Lfbyte_loop
+$Lfsrc_unaligned:
+	! adjust A1.2
+	LSR 	D1Ar5, D1Ar3, #3
+
+	MOV 	D0Ar4, A1.2
+	MOV 	D0Ar6, A1.2
+	ANDMB 	D0Ar4, D0Ar4, #0xfff8
+	MOV 	A1.2, D0Ar4
+
+	! A0.2 dst 64-bit is aligned
+	SUB 	D0Ar6, D0Ar6, D0Ar4
+	! keep the information for the later adjustment
+	MOVS 	D0Ar4, D0Ar6
+
+	! both aligned
+	BZ 	$Lfaligned_loop
+
+	! prefetch
+	GETL 	D0Re0, D1Re0, [A1.2]
+
+	CMP 	D0Ar6, #4
+	BLT 	$Lfunaligned_1_2_3
+	BZ 	$Lfaligned_4
+
+	SUB 	D0Ar6, D0Ar6, #4
+	MULW 	D0.6, D0Ar6, #8
+	MOV 	D1.6, #32
+	SUB 	D1.6, D1.6, D0.6
+
+$Lfunaligned_5_6_7:
+	GETL 	D0.7, D1.7, [++A1.2]
+	! form 64-bit data in D0Re0, D1Re0
+	MOV 	D0Re0, D1Re0
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D1Re0, D0.7
+	LSL 	D1Re0, D1Re0, D1.6
+	MOV 	D0.5, D1Re0
+	ADD 	D0Re0, D0Re0, D0.5
+
+	MOV 	D0.5, D0.7
+	LSR 	D0.5, D0.5, D0.6
+	MOV 	D1Re0, D1.7
+	LSL 	D1Re0, D1Re0, D1.6
+	MOV 	D1.5, D0.5
+	ADD 	D1Re0, D1Re0, D1.5
+
+	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lfunaligned_5_6_7
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lfbyte_loop_exit
+	! Adjust A1.2
+	ADD	A1.2, A1.2, D0Ar4
+	B 	$Lfbyte_loop
+
+$Lfunaligned_1_2_3:
+	MULW 	D0.6, D0Ar6, #8
+	MOV 	D1.6, #32
+	SUB 	D1.6, D1.6, D0.6
+
+$Lfunaligned_1_2_3_loop:
+	GETL 	D0.7, D1.7, [++A1.2]
+	! form 64-bit data in D0Re0, D1Re0
+	LSR 	D0Re0, D0Re0, D0.6
+	MOV 	D1.5, D1Re0
+	LSL 	D1Re0, D1Re0, D1.6
+	MOV 	D0.5, D1Re0
+	ADD 	D0Re0, D0Re0, D0.5
+
+	MOV 	D0.5, D1.5
+	LSR 	D0.5, D0.5, D0.6
+	MOV 	D1Re0, D0.7
+	LSL 	D1Re0, D1Re0, D1.6
+	MOV 	D1.5, D0.5
+	ADD 	D1Re0, D1Re0, D1.5
+
+	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lfunaligned_1_2_3_loop
+
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lfbyte_loop_exit
+	! Adjust A1.2
+	ADD	A1.2, A1.2, D0Ar4
+	B 	$Lfbyte_loop
+
+$Lfaligned_4:
+	GETL 	D0.7, D1.7, [++A1.2]
+	MOV 	D0Re0, D1Re0
+	MOV 	D1Re0, D0.7
+	SETL 	[A0.2++], D0Re0, D1Re0
+	MOV 	D0Re0, D0.7
+	MOV 	D1Re0, D1.7
+	SUBS 	D1Ar5, D1Ar5, #1
+	BNE 	$Lfaligned_4
+	ANDS 	D1Ar3, D1Ar3, #7
+	BZ 	$Lfbyte_loop_exit
+	! Adjust A1.2
+	ADD	A1.2, A1.2, D0Ar4
+	B 	$Lfbyte_loop
+
+	.size _memmove,.-_memmove
+
+libc_hidden_def(memmove)
diff --git a/libc/string/metag/memset.S b/libc/string/metag/memset.S
new file mode 100644
index 0000000..56d15e8
--- /dev/null
+++ b/libc/string/metag/memset.S
@@ -0,0 +1,87 @@
+!   Copyright (C) 2008-2012 Imagination Technologies Ltd.
+
+	.text
+	.global	_memset
+	.type	_memset,function
+! D1Ar1 dst
+! D0Ar2 c
+! D1Ar3 cnt
+! D0Re0 dst
+_memset:
+	AND	D0Ar2,D0Ar2,#0xFF	! Ensure a byte input value
+	MULW 	D0Ar2,D0Ar2,#0x0101	! Duplicate byte value into  0-15
+	ANDS	D0Ar4,D1Ar1,#7		! Extract bottom LSBs of dst
+	LSL 	D0Re0,D0Ar2,#16		! Duplicate byte value into 16-31
+	ADD	A0.2,D0Ar2,D0Re0	! Duplicate byte value into 4 (A0.2)
+	MOV	D0Re0,D1Ar1		! Return dst
+	BZ	$LLongStub		! if start address is aligned
+	! start address is not aligned on an 8 byte boundary, so we 
+	! need the number of bytes up to the next 8 byte address
+	! boundary, or the length of the string if less than 8, in D1Ar5
+	MOV	D0Ar2,#8		! Need 8 - N in D1Ar5 ...
+	SUB	D1Ar5,D0Ar2,D0Ar4	!            ... subtract N
+	CMP	D1Ar3,D1Ar5
+	MOVMI	D1Ar5,D1Ar3
+	B	$LByteStub		! dst is mis-aligned, do $LByteStub
+
+!
+! Preamble to LongLoop which generates 4*8 bytes per interation (5 cycles)
+!
+$LLongStub:
+	LSRS	D0Ar2,D1Ar3,#5
+	AND	D1Ar3,D1Ar3,#0x1F
+	MOV	A1.2,A0.2
+	BEQ	$LLongishStub
+	SUB	TXRPT,D0Ar2,#1
+	CMP	D1Ar3,#0
+$LLongLoop:
+	SETL 	[D1Ar1++],A0.2,A1.2
+	SETL 	[D1Ar1++],A0.2,A1.2
+	SETL 	[D1Ar1++],A0.2,A1.2
+	SETL 	[D1Ar1++],A0.2,A1.2
+	BR	$LLongLoop
+	BZ	$Lexit
+!
+! Preamble to LongishLoop which generates 1*8 bytes per interation (2 cycles)
+!
+$LLongishStub:
+	LSRS	D0Ar2,D1Ar3,#3
+	AND	D1Ar3,D1Ar3,#0x7
+	MOV	D1Ar5,D1Ar3
+	BEQ	$LByteStub
+	SUB	TXRPT,D0Ar2,#1
+	CMP	D1Ar3,#0
+$LLongishLoop:
+	SETL 	[D1Ar1++],A0.2,A1.2
+	BR	$LLongishLoop
+	BZ	$Lexit
+!
+! This does a byte structured burst of up to 7 bytes
+!
+!	D1Ar1 should point to the location required
+!	D1Ar3 should be the remaining total byte count
+!	D1Ar5 should be burst size (<= D1Ar3)
+!
+$LByteStub:
+	SUBS	D1Ar3,D1Ar3,D1Ar5	! Reduce count
+	ADD	D1Ar1,D1Ar1,D1Ar5	! Advance pointer to end of area
+	MULW	D1Ar5,D1Ar5,#4		! Scale to (1*4), (2*4), (3*4)
+	SUB	D1Ar5,D1Ar5,#(8*4)	! Rebase to -(7*4), -(6*4), -(5*4), ...
+	MOV	A1.2,D1Ar5
+	SUB	PC,CPC1,A1.2		! Jump into table below
+	SETB 	[D1Ar1+#(-7)],A0.2
+	SETB 	[D1Ar1+#(-6)],A0.2
+	SETB 	[D1Ar1+#(-5)],A0.2
+	SETB 	[D1Ar1+#(-4)],A0.2
+	SETB 	[D1Ar1+#(-3)],A0.2
+	SETB 	[D1Ar1+#(-2)],A0.2
+	SETB 	[D1Ar1+#(-1)],A0.2
+!
+! Return if all data has been output, otherwise do $LLongStub
+!
+	BNZ	$LLongStub
+$Lexit:
+	MOV	PC,D1RtP
+        .size _memset,.-_memset
+
+libc_hidden_def(memset)
diff --git a/libc/string/metag/strchr.S b/libc/string/metag/strchr.S
new file mode 100644
index 0000000..eb73668
--- /dev/null
+++ b/libc/string/metag/strchr.S
@@ -0,0 +1,164 @@
+!  Copyright (C) 2008,2010,2012 Imagination Technologies Ltd.
+
+#include <features.h>
+
+	.text
+	.global	_strchr
+	.type	_strchr, function
+! D1Ar1 src
+! D0Ar2 c
+_strchr:
+	AND     D0Ar2,D0Ar2,#0xff                           ! Drop all but 8 bits of c
+	MOV 	D1Ar5, D1Ar1                                ! Copy src to D1Ar5
+	AND 	D1Ar5, D1Ar5, #7                            ! Check 64 bit alignment
+	CMP 	D1Ar5, #0
+	BZ 	$Laligned64bit                              ! Jump to 64 bit aligned strchr
+$Lalign64bit:
+	GETB 	D0Re0, [D1Ar1++]                            ! Get the next character
+	ADD 	D1Ar5, D1Ar5, #1                            ! Increment alignment counter
+	CMP 	D0Re0, D0Ar2                                ! Is the char c
+	BZ 	$Lcharatprevious                            ! If so exit returning position
+	CMP 	D0Re0, #0                                   ! End of string?
+	BZ 	$Lnotfound                                  ! If so exit
+	CMP 	D1Ar5, #8                                   ! Are we aligned 64bit yet?
+	BNZ 	$Lalign64bit                                ! If not keep aligning
+$Laligned64bit:                                             ! src is 64bit aligned
+	MOV 	D0Ar4, D0Ar2                                ! put c into D0Ar4
+	LSL 	D0Ar4, D0Ar4, #8                            ! Shift it up
+	ADD 	D0Ar4, D0Ar4, D0Ar2                         ! another c
+	LSL 	D0Ar4, D0Ar4, #8                            ! shift
+	ADD 	D0Ar4, D0Ar4, D0Ar2                         ! another c
+	LSL 	D0Ar4, D0Ar4, #8                            ! shift
+	ADD 	D0Ar4, D0Ar4, D0Ar2                         ! 4 copies of c
+$Lcheck8bytes:
+	GETL 	D0Re0, D1Re0, [D1Ar1++]                     ! grab 16 bytes
+	MOV 	A0.3, D0Re0                                 ! save for later use
+							    ! first word
+							    ! check for \0
+	MOV 	D0Ar2, D0Re0                                ! D0Ar2 is a scratch now
+	ADDT 	D0Re0, D0Re0, #HI(0xfefefeff)               ! Do 4 1-byte compares
+	ADD 	D0Re0, D0Re0, #LO(0xfefefeff)
+	XOR 	D0Ar2, D0Ar2, #-1
+	AND 	D0Re0, D0Re0, D0Ar2
+	ANDMT 	D0Re0, D0Re0, #HI(0x80808080)
+	ANDMB 	D0Re0, D0Re0, #LO(0x80808080)
+	CMP 	D0Re0, #0
+	BNZ 	$Lnullinword1                               ! found \0 (or c if c==\0)
+
+							    ! Check for c
+	MOV 	D0Re0, A0.3                                 ! restore the first word
+	XOR 	D0Re0, D0Re0, D0Ar4
+	MOV 	D0Ar2, D0Re0                                ! DO 4 1-byte compares
+	ADDT 	D0Re0, D0Re0, #HI(0xfefefeff)
+	ADD 	D0Re0, D0Re0, #LO(0xfefefeff)
+	XOR 	D0Ar2, D0Ar2, #-1
+	AND 	D0Re0, D0Re0, D0Ar2
+	ANDMT 	D0Re0, D0Re0, #HI(0x80808080)
+	ANDMB 	D0Re0, D0Re0, #LO(0x80808080)
+	CMP 	D0Re0, #0
+	BNZ 	$Lcharinword1                               ! found c
+
+							    ! second word
+							    ! check for \0
+	MOV 	A0.3, D1Re0                                 ! save for later use
+	MOV 	D1Ar3, D1Re0
+	ADDT 	D1Re0, D1Re0, #HI(0xfefefeff)               ! Do 4 1-byte compares
+	ADD 	D1Re0, D1Re0, #LO(0xfefefeff)
+	XOR 	D1Ar3, D1Ar3, #-1
+	AND 	D1Re0, D1Re0, D1Ar3
+	ANDMT 	D1Re0, D1Re0, #HI(0x80808080)
+	ANDMB 	D1Re0, D1Re0, #LO(0x80808080)
+	CMP 	D1Re0, #0
+	BNZ 	$Lnullinword2                               ! Found \0 (or c if c==\0)
+
+	MOV 	D0.4, A0.3                                  ! restore the second word
+	XOR 	D1Re0, D0.4, D0Ar4                          ! test c
+
+	MOV 	D1Ar3, D1Re0
+	ADDT 	D1Re0, D1Re0, #HI(0xfefefeff)               ! Do 4 1-byte compares
+	ADD 	D1Re0, D1Re0, #LO(0xfefefeff)
+	XOR 	D1Ar3, D1Ar3, #-1
+	AND 	D1Re0, D1Re0, D1Ar3
+	ANDMT 	D1Re0, D1Re0, #HI(0x80808080)
+	ANDMB 	D1Re0, D1Re0, #LO(0x80808080)
+	CMP 	D1Re0, #0
+	BNZ 	$Lcharinword2                               ! found c
+
+	B 	$Lcheck8bytes                               ! Keep checking
+
+$Lnullinword1:                                              ! found \0 somewhere, check for c too
+	SUB 	D1Ar1, D1Ar1, #4
+$Lnullinword2:
+	SUB 	D1Ar1, D1Ar1, #4
+	AND 	D0Ar2, D0Ar4, #0xff                         ! restore c
+	MOV 	D0Re0, A0.3                                 ! restore the word
+	MOV 	D0.4, D0Re0                                 ! for shifting later
+	AND 	D0Re0, D0Re0, #0xff                         ! take first byte of word
+	CMP 	D0Re0, D0Ar2
+	BZ 	$Lcharatcurrent                             ! found c
+	CMP 	D0Re0, #0!
+	BZ 	$Lnotfound                                  ! found \0
+
+	ADD 	D1Ar1, D1Ar1, #1
+	LSR 	D0.4, D0.4, #8
+	MOV 	D0Re0, D0.4
+	AND 	D0Re0, D0Re0, #0xff                         ! take second byte of word
+	CMP 	D0Re0, D0Ar2
+	BZ 	$Lcharatcurrent                             ! found c
+	CMP 	D0Re0, #0
+	BZ 	$Lnotfound                                  ! found \0
+
+	ADD 	D1Ar1, D1Ar1, #1
+	LSR 	D0.4, D0.4, #8
+	MOV 	D0Re0, D0.4
+	AND 	D0Re0, D0Re0, #0xff                         ! take third byte of word
+	CMP 	D0Re0, D0Ar2
+	BZ 	$Lcharatcurrent                             ! found c
+	CMP 	D0Re0, #0
+	BZ 	$Lnotfound                                  ! found \0
+
+	ADD 	D1Ar1, D1Ar1, #1                            ! move to 4th byte
+	CMP     D0Ar2, #0                                   ! If c was \0
+	BZ      $Lcharatcurrent                             ! c has been found!
+
+$Lnotfound:
+	MOV 	D0Re0,		#0                          ! End of string c not found
+	B 	$Lend
+
+$Lcharinword1: 						    ! found c in first word
+	MOV 	D1Re0, D0Re0
+	SUB 	D1Ar1, D1Ar1, #4
+$Lcharinword2:                                              ! found c in second word
+	SUB 	D1Ar1, D1Ar1, #4
+
+	AND 	D0Re0, D1Re0, #0xff                         ! First byte
+	CMP 	D0Re0, #0                                   ! Test c (zero indicates c due
+							    ! to the 4 1-byte compare code)
+	BNE 	$Lcharatcurrent
+	ADD 	D1Ar1, D1Ar1, #1
+
+	LSR 	D1Re0, D1Re0, #8
+	AND 	D0Re0, D1Re0, #0xff                         ! Second byte
+	CMP 	D0Re0, #0                                   ! Test c (indicated by zero)
+	BNE 	$Lcharatcurrent
+	ADD 	D1Ar1, D1Ar1, #1
+
+	LSR 	D1Re0, D1Re0, #8
+	AND 	D0Re0, D1Re0, #0xff                         ! Third byte
+	CMP 	D0Re0, #0                                   ! Test c (indicated by zero)
+	BNE 	$Lcharatcurrent
+	ADD 	D1Ar1, D1Ar1, #1                            ! Must be the fourth byte
+	B 	$Lcharatcurrent
+
+$Lcharatprevious:
+	SUB 	D1Ar1, D1Ar1, #1                            ! Fix-up pointer
+$Lcharatcurrent:
+	MOV 	D0Re0, D1Ar1                                ! Return the string pointer
+$Lend:
+	MOV 	PC, D1RtP
+	.size _strchr,.-_strchr
+
+libc_hidden_def(strchr)
+#ifdef __UCLIBC_SUSV3_LEGACY__
+strong_alias(strchr,index)
+#endif
diff --git a/libc/string/metag/strcmp.S b/libc/string/metag/strcmp.S
new file mode 100644
index 0000000..a9d82cc
--- /dev/null
+++ b/libc/string/metag/strcmp.S
@@ -0,0 +1,62 @@
+!   Copyright (C) 2008 Imagination Technologies Ltd.
+
+#include <features.h>
+
+	.text
+	.global	_strcmp
+	.type	_strcmp,function
+!D1Ar1 s1
+!D0Ar2 s2
+_strcmp:
+	TST	D1Ar1,#3
+	TSTZ	D0Ar2,#3
+	MOVT	D1Re0,#0x0101
+	ADD	D1Re0,D1Re0,#0x0101
+	BNZ	$Lstrcmp_slow
+	GETD	D1Ar3,[D1Ar1+#4++]	! Load 32-bits from s1
+	GETD	D1Ar5,[D0Ar2+#4++]      ! Load 32-bits from s2
+	LSL	D0FrT,D1Re0,#7		! D0FrT = 0x80808080
+$Lstrcmp4_loop:
+	SUB	D0Re0,D1Ar3,D1Re0	! D1Re0 = 0x01010101
+	MOV	D0Ar6,D1Ar3
+	SUBS	D0Ar4,D1Ar3,D1Ar5	! Calculate difference
+	XOR	D0Ar6,D0Ar6,#-1
+	GETD	D1Ar3,[D1Ar1+#4++]	! Load 32-bits from s1
+	AND	D0Re0,D0Re0,D0Ar6
+	ANDSZ	D0Ar6,D0Re0,D0FrT	! D0FrT = 0x80808080
+	GETD	D1Ar5,[D0Ar2+#4++]      ! Load 32-bits from s2
+	BZ	$Lstrcmp4_loop
+	AND	D0Ar6, D0Re0, D0FrT	! D0FrT = 0x80808080
+!
+! Either they are different or they both contain a NULL + junk
+!
+$Lstrcmp4_end:
+	LSLS	D0Re0,D0Ar4,#24		! Was Byte[0] the same?
+	LSLSZ	D0Ar2,D0Ar6,#24		! Yes: AND they where not zero?
+	LSLSZ	D0Re0,D0Ar4,#16		! Yes: Was Byte[1] the same?
+	LSLSZ	D0Ar2,D0Ar6,#16		! Yes: AND they where not zero?
+	LSLSZ	D0Re0,D0Ar4,#8		! Tes: Was Byte[2] the same?
+	LSLSZ	D0Ar2,D0Ar6,#8		! Yes: AND they where not zero?
+	MOVZ	D0Re0,D0Ar4		! Yes: Must by Byte[3] thats the result
+	ASR	D0Re0,D0Re0,#24		! Sign extend result to integer
+	MOV	PC,D1RtP
+!
+! Misaligned case, byte at a time
+!
+$Lstrcmp_slow:
+	GETB	D1Ar3,[D1Ar1++]		! Load char from s1
+	GETB	D1Ar5,[D0Ar2++]         ! Load char from s2
+	CMP	D1Ar3,#1		! Null -> C and NZ, rest -> NC (\1->Z)
+	CMPNC	D1Ar3,D1Ar5		! NOT Null: Same -> Z, else -> NZ
+	BZ	$Lstrcmp_slow		! NOT Null and Same: Loop
+	SUB	D0Re0,D1Ar3,D1Ar5	! Generate result
+	MOV	PC,D1RtP
+
+        .size _strcmp,.-_strcmp
+
+
+libc_hidden_def(strcmp)
+#ifndef __UCLIBC_HAS_LOCALE__
+strong_alias(strcmp,strcoll)
+libc_hidden_def(strcoll)
+#endif
diff --git a/libc/string/metag/strcpy.S b/libc/string/metag/strcpy.S
new file mode 100644
index 0000000..d57bd25
--- /dev/null
+++ b/libc/string/metag/strcpy.S
@@ -0,0 +1,91 @@
+!   Copyright (C) 2008,2012 Imagination Technologies Ltd.
+
+	.text
+	.global	_strcpy
+	.type	_strcpy,function
+! D1Ar1 dst
+! D0Ar2 src
+
+_strcpy:
+	MOV	A1.2, D1Ar1
+
+	! test 4 byte alignment of src
+	ANDS	D0Ar4, D0Ar2, #3
+	BNZ	$Lbyteloop
+
+	! test 4 byte alignment of dest
+	ANDS	D1Ar5, D1Ar1, #3
+	BNZ	$Lbyteloop
+
+	! load mask values for aligned loops
+	MOVT	D1Ar3, #HI(0xfefefeff)
+	ADD	D1Ar3, D1Ar3, #LO(0xfefefeff)
+	MOVT	D0FrT, #HI(0x80808080)
+	ADD	D0FrT, D0FrT, #LO(0x80808080)
+
+	! test 8 byte alignment of src
+	ANDS	D0Ar4, D0Ar2, #7
+	BNZ	$Lwordloop
+
+	! test 8 byte alignment of dest
+	ANDS	D1Ar5, D1Ar1, #7
+	BNZ	$Lwordloop
+
+$L8byteloop:
+	GETL	D1Ar5, D0Ar6, [D0Ar2++]
+	MOV	D1Re0, D1Ar5
+	MOV	D0Re0, D1Ar5
+	ADD	D1Re0, D1Re0, D1Ar3
+	XOR	D0Re0, D0Re0, #-1
+	AND	D1Re0, D1Re0, D0Re0
+	ANDS	D1Re0, D1Re0, D0FrT
+	BNZ	$Lnullfound		! NULL in first word
+
+	MOV	D1Re0, D0Ar6
+	MOV	D0Re0, D0Ar6
+	ADD	D1Re0, D1Re0, D1Ar3
+	XOR	D0Re0, D0Re0, #-1
+	AND	D1Re0, D1Re0, D0Re0
+	ANDS	D1Re0, D1Re0, D0FrT
+	BNZ	$Lnullfound2		! NULL in the second word
+
+	SETL	[A1.2++], D1Ar5, D0Ar6
+	B	$L8byteloop
+
+$Lwordloop:
+	GETD	D0Ar6, [D0Ar2++]
+	MOV	D1Re0, D0Ar6
+	MOV	D0Re0, D0Ar6
+	ADD	D1Re0, D1Re0, D1Ar3
+	XOR	D0Re0, D0Re0, #-1
+	AND	D1Re0, D1Re0, D0Re0
+	ANDS	D1Re0, D1Re0, D0FrT
+	MOV	D1Ar5, D0Ar6
+	BNZ	$Lnullfound
+	SETD	[A1.2++], D0Ar6
+	B	$Lwordloop
+
+$Lnullfound2:
+	SETD	[A1.2++], D1Ar5
+	MOV	D1Ar5, D0Ar6
+
+$Lnullfound:
+	SETB	[A1.2++], D1Ar5
+	ANDS	D0Ar6, D1Ar5, #0xff
+	LSR	D1Ar5, D1Ar5, #8
+	BNZ	$Lnullfound
+	B	$Lend
+
+$Lbyteloop:
+	GETB	D0Ar6, [D0Ar2++]
+	SETB	[A1.2++], D0Ar6
+	CMP	D0Ar6, #0
+	BNZ	$Lbyteloop
+
+$Lend:
+	MOV	D0Re0, D1Ar1
+	MOV	PC, D1RtP
+
+	.size _strcpy,.-_strcpy
+
+libc_hidden_def(strcpy)
diff --git a/libc/sysdeps/linux/common/Makefile.in b/libc/sysdeps/linux/common/Makefile.in
index 3b5763c..e0312b9 100644
--- a/libc/sysdeps/linux/common/Makefile.in
+++ b/libc/sysdeps/linux/common/Makefile.in
@@ -64,9 +64,10 @@ CSRC-$(if $(findstring yy,$(UCLIBC_LINUX_SPECIFIC)$(UCLIBC_HAS_LFS)),y) += \
 # NPTL needs these internally: madvise.c
 CSRC-$(findstring y,$(UCLIBC_LINUX_SPECIFIC)$(UCLIBC_HAS_THREADS_NATIVE)) += madvise.c
 ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
-CSRC- += fork.c getpid.c raise.c open.c close.c read.c write.c
+CSRC- += fork.c getpid.c raise.c openat.c close.c read.c write.c
 CSRC- += $(if $(findstring =arm=,=$(TARGET_ARCH)=),vfork.c)
 CSRC- += $(if $(findstring =x86_64=,=$(TARGET_ARCH)=),vfork.c)
+CSRC- += $(if $(findstring =metag=,=$(TARGET_ARCH)=),vfork.c)
 CSRC- += $(if $(findstring =mips=y=,=$(TARGET_ARCH)=$(CONFIG_MIPS_O32_ABI)=),waitpid.c)
 endif
 # stubbed out in mman.h
diff --git a/libc/sysdeps/linux/common/__syscall_fcntl.c b/libc/sysdeps/linux/common/__syscall_fcntl.c
index 6d4c339..83fad3d 100644
--- a/libc/sysdeps/linux/common/__syscall_fcntl.c
+++ b/libc/sysdeps/linux/common/__syscall_fcntl.c
@@ -19,6 +19,53 @@
 extern __typeof(fcntl) __libc_fcntl;
 libc_hidden_proto(__libc_fcntl)
 
+
+#if defined(__NR_fcntl64) && ! defined (__NR_fcntl)
+
+int __libc_fcntl (int fd, int cmd, ...)
+{
+	va_list ap;
+	void* arg;
+
+	va_start (ap, cmd);
+	arg = va_arg (ap, void*);
+	va_end (ap);
+
+	return INLINE_SYSCALL(fcntl64, 3, fd, cmd, arg);
+}
+libc_hidden_def(__libc_fcntl)
+
+int __fcntl_nocancel (int fd, int cmd, ...)
+{
+	va_list ap;
+	void* arg;
+
+	va_start (ap, cmd);
+	arg = va_arg (ap, void*);
+	va_end (ap);
+
+#ifdef __UCLIBC_HAS_THREADS_NATIVE__
+	if (SINGLE_THREAD_P)
+		return INLINE_SYSCALL(fcntl64, 3, fd, cmd, arg);
+
+	int oldtype = LIBC_CANCEL_ASYNC ();
+
+	int result = INLINE_SYSCALL(fcntl64, 3, fd, cmd, arg);
+
+	LIBC_CANCEL_RESET (oldtype);
+
+	return result;
+
+#else
+
+	return INLINE_SYSCALL (fcntl64, 3, fd, cmd, arg);
+
+#endif
+}
+libc_hidden_def(__fcntl_nocancel)
+
+#else
+
 int __fcntl_nocancel (int fd, int cmd, ...)
 {
 	va_list ap;
@@ -70,7 +117,9 @@ int __libc_fcntl (int fd, int cmd, ...)
 	LIBC_CANCEL_RESET (oldtype);
 
 	return result;
-#else
+
+#else /* __UCLIBC_HAS_THREADS_NATIVE__ */
+
 # if __WORDSIZE == 32
 	if (cmd == F_GETLK64 || cmd == F_SETLK64 || cmd == F_SETLKW64) {
 #  if defined __UCLIBC_HAS_LFS__ && defined __NR_fcntl64
@@ -80,12 +129,14 @@ int __libc_fcntl (int fd, int cmd, ...)
 		return -1;
 #  endif
 	}
-# endif
+# endif /* __WORDSIZE */
 	return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
-#endif
+#endif /* __UCLIBC_HAS_THREADS_NATIVE__ */
 }
 libc_hidden_def(__libc_fcntl)
 
+#endif
+
 libc_hidden_proto(fcntl)
 weak_alias(__libc_fcntl,fcntl)
 libc_hidden_weak(fcntl)
diff --git a/libc/sysdeps/linux/common/__syscall_fcntl64.c b/libc/sysdeps/linux/common/__syscall_fcntl64.c
index e8782e9..93fdb16 100644
--- a/libc/sysdeps/linux/common/__syscall_fcntl64.c
+++ b/libc/sysdeps/linux/common/__syscall_fcntl64.c
@@ -27,4 +27,9 @@ int fcntl64(int fd, int cmd, ...)
 	return (__syscall_fcntl64(fd, cmd, arg));
 }
 libc_hidden_def(fcntl64)
+
+#if ! defined(__NR_fcntl)
+strong_alias(fcntl64, fcntl)
+#endif /* ! __NR_fcntl__ */
+
 #endif
diff --git a/libc/sysdeps/linux/common/access.c b/libc/sysdeps/linux/common/access.c
index a075d42..f8c52fc 100644
--- a/libc/sysdeps/linux/common/access.c
+++ b/libc/sysdeps/linux/common/access.c
@@ -8,5 +8,15 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
+
+#if defined(__NR_faccessat) && ! defined(__NR_access)
+int access(const char* pathname, int mode)
+{
+	return faccessat(AT_FDCWD, pathname, mode, 0);
+}
+
+#else
 _syscall2(int, access, const char *, pathname, int, mode)
+#endif
diff --git a/libc/sysdeps/linux/common/chmod.c b/libc/sysdeps/linux/common/chmod.c
index 871e023..9ceb8c6 100644
--- a/libc/sysdeps/linux/common/chmod.c
+++ b/libc/sysdeps/linux/common/chmod.c
@@ -9,8 +9,16 @@
 
 #include <sys/syscall.h>
 #include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
 
+#if defined(__NR_fchmodat) && ! defined(__NR_chmod)
+int chmod(const char* path, mode_t mode)
+{
+	return fchmodat(AT_FDCWD, path, mode, 0);
+}
 
+#else
 #define __NR___syscall_chmod __NR_chmod
 static __inline__ _syscall2(int, __syscall_chmod, const char *, path, __kernel_mode_t, mode)
 
@@ -18,4 +26,5 @@ int chmod(const char *path, mode_t mode)
 {
 	return __syscall_chmod(path, mode);
 }
+#endif
 libc_hidden_def(chmod)
diff --git a/libc/sysdeps/linux/common/chown.c b/libc/sysdeps/linux/common/chown.c
index f2c60e0..4cc686b 100644
--- a/libc/sysdeps/linux/common/chown.c
+++ b/libc/sysdeps/linux/common/chown.c
@@ -8,9 +8,17 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
 
+#if defined(__NR_fchownat) && ! defined(__NR_chown)
+int chown(const char *path, uid_t owner, gid_t group)
+{
+	return fchownat(AT_FDCWD, path, owner, group, 0);
+}
+
+#else
 
 #if (__WORDSIZE == 32 && defined(__NR_chown32)) || __WORDSIZE == 64
 # ifdef __NR_chown32
@@ -37,4 +45,5 @@ int chown(const char *path, uid_t owner, gid_t group)
 }
 #endif
 
+#endif
 libc_hidden_def(chown)
diff --git a/libc/sysdeps/linux/common/dup2.c b/libc/sysdeps/linux/common/dup2.c
index 006f06b..e58105d 100644
--- a/libc/sysdeps/linux/common/dup2.c
+++ b/libc/sysdeps/linux/common/dup2.c
@@ -10,6 +10,12 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
-
+#if defined(__NR_dup3) && ! defined(__NR_dup2)
+int dup2(int old, int newfd)
+{
+	return dup3(old, newfd, 0);
+}
+#else
 _syscall2(int, dup2, int, oldfd, int, newfd)
+#endif
 libc_hidden_def(dup2)
diff --git a/libc/sysdeps/linux/common/dup3.c b/libc/sysdeps/linux/common/dup3.c
new file mode 100644
index 0000000..3e7c813
--- /dev/null
+++ b/libc/sysdeps/linux/common/dup3.c
@@ -0,0 +1,17 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * dup3() for uClibc
+ *
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <sys/syscall.h>
+#include <unistd.h>
+
+
+#if defined(__NR_dup3)
+_syscall3(int, dup3, int, oldfd, int, newfd, int, flags)
+libc_hidden_def(dup3)
+#endif
diff --git a/libc/sysdeps/linux/common/epoll.c b/libc/sysdeps/linux/common/epoll.c
index ab3e73b..ba907fa 100644
--- a/libc/sysdeps/linux/common/epoll.c
+++ b/libc/sysdeps/linux/common/epoll.c
@@ -16,17 +16,25 @@
 #endif
 
 /*
- * epoll_create()
+ * epoll_create1()
  */
-#ifdef __NR_epoll_create
-_syscall1(int, epoll_create, int, size)
+#if defined(__NR_epoll_create1)
+_syscall1(int, epoll_create1, int, flags)
 #endif
 
+#if defined(__NR_epoll_create1) && ! defined(__NR_epoll_create)
+int epoll_create(int size)
+{
+	return INLINE_SYSCALL(epoll_create1, 1, 0);
+}
+
 /*
- * epoll_create1()
+ * epoll_create()
  */
-#ifdef __NR_epoll_create1
-_syscall1(int, epoll_create1, int, flags)
+
+/* For systems that have both, prefer the old one */
+#else
+_syscall1(int, epoll_create, int, size)
 #endif
 
 /*
@@ -79,5 +87,15 @@ int __libc_epoll_pwait(int epfd, struct epoll_event *events, int maxevents,
 	}
 # endif
 }
+/*
+ * If epoll_wait is not defined, then call epoll_pwait instead using NULL
+ * for sigmask argument
+ */
+#if ! defined(__NR_epoll_wait)
+int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
+{
+	return INLINE_SYSCALL(epoll_pwait, 5, epfd, events, maxevents, timeout, NULL);
+}
+#endif
 weak_alias(__libc_epoll_pwait, epoll_pwait)
 #endif
diff --git a/libc/sysdeps/linux/common/eventfd.c b/libc/sysdeps/linux/common/eventfd.c
index cc3f3f0..c208996 100644
--- a/libc/sysdeps/linux/common/eventfd.c
+++ b/libc/sysdeps/linux/common/eventfd.c
@@ -13,6 +13,12 @@
 /*
  * eventfd()
  */
-#ifdef __NR_eventfd
+#if defined(__NR_eventfd2) && ! defined(__NR_eventfd)
+int eventfd(int count, int flags)
+{
+	return INLINE_SYSCALL(eventfd2, 2, count, flags);
+}
+
+#else
 _syscall2(int, eventfd, int, count, int, flags)
 #endif
diff --git a/libc/sysdeps/linux/common/fork.c b/libc/sysdeps/linux/common/fork.c
index 14e00a2..0b58fa9 100644
--- a/libc/sysdeps/linux/common/fork.c
+++ b/libc/sysdeps/linux/common/fork.c
@@ -9,10 +9,28 @@
 
 #include <sys/syscall.h>
 #include <unistd.h>
+#include <unistd.h>
+#include <signal.h>
 
 #ifdef __ARCH_USE_MMU__
 
-#ifdef __NR_fork
+#if defined(__NR_clone) && ! defined(__NR_fork)
+pid_t __libc_fork(void)
+{
+	pid_t pid;
+	pid = INLINE_SYSCALL(clone, 4, SIGCHLD, NULL, NULL, NULL);
+
+	if (pid<0) {
+		__set_errno(-pid);
+		return -1;
+	}
+
+	return pid;
+}
+weak_alias(__libc_fork,fork)
+libc_hidden_weak(fork)
+
+#elif defined(__NR_fork)
 #define __NR___libc_fork __NR_fork
 extern __typeof(fork) __libc_fork;
 _syscall0(pid_t, __libc_fork)
diff --git a/libc/sysdeps/linux/common/fstat.c b/libc/sysdeps/linux/common/fstat.c
index 4726a68..4d55dc3 100644
--- a/libc/sysdeps/linux/common/fstat.c
+++ b/libc/sysdeps/linux/common/fstat.c
@@ -12,6 +12,22 @@
 #include <sys/stat.h>
 #include "xstatconv.h"
 
+#if defined(__NR_fstat64) && ! defined(__NR_fstat)
+int fstat(int fd, struct stat *buf)
+{
+	int result;
+	struct kernel_stat64 kbuf;
+
+	result = INLINE_SYSCALL(fstat64, 2, fd, &kbuf);
+
+	if (result == 0)
+		__xstat32_conv(&kbuf, buf);
+
+	return result;
+}
+libc_hidden_def(fstat)
+
+#elif defined(__NR_fstat)
 int fstat(int fd, struct stat *buf)
 {
 	int result;
@@ -38,7 +54,9 @@ int fstat(int fd, struct stat *buf)
 }
 libc_hidden_def(fstat)
 
-#if ! defined __NR_fstat64 && defined __UCLIBC_HAS_LFS__
+#if ! defined (__NR_fstat64) && defined __UCLIBC_HAS_LFS__
 strong_alias_untyped(fstat,fstat64)
 libc_hidden_def(fstat64)
 #endif
+
+#endif
diff --git a/libc/sysdeps/linux/common/fstatat.c b/libc/sysdeps/linux/common/fstatat.c
index 33daa7c..a0bc3cd 100644
--- a/libc/sysdeps/linux/common/fstatat.c
+++ b/libc/sysdeps/linux/common/fstatat.c
@@ -11,7 +11,7 @@
 #include "xstatconv.h"
 
 /* 64bit ports tend to favor newfstatat() */
-#ifdef __NR_newfstatat
+#if __WORDSIZE == 64 && defined __NR_newfstatat
 # define __NR_fstatat64 __NR_newfstatat
 #endif
 
diff --git a/libc/sysdeps/linux/common/fstatat64.c b/libc/sysdeps/linux/common/fstatat64.c
index 95627af..203ec4c 100644
--- a/libc/sysdeps/linux/common/fstatat64.c
+++ b/libc/sysdeps/linux/common/fstatat64.c
@@ -13,7 +13,7 @@
 #ifdef __UCLIBC_HAS_LFS__
 
 /* 64bit ports tend to favor newfstatat() */
-#ifdef __NR_newfstatat
+#if __WORDSIZE == 64 && defined __NR_newfstatat
 # define __NR_fstatat64 __NR_newfstatat
 #endif
 
diff --git a/libc/sysdeps/linux/common/fstatfs.c b/libc/sysdeps/linux/common/fstatfs.c
index fa0024a..82efdc9 100644
--- a/libc/sysdeps/linux/common/fstatfs.c
+++ b/libc/sysdeps/linux/common/fstatfs.c
@@ -9,8 +9,9 @@
 
 #include <sys/syscall.h>
 #include <sys/vfs.h>
+#include <string.h>
 
-#ifndef __USE_FILE_OFFSET64
+#if ! defined(__USE_FILE_OFFSET64)
 extern int fstatfs (int __fildes, struct statfs *__buf)
      __THROW __nonnull ((2));
 #else
@@ -23,8 +24,48 @@ extern int __REDIRECT_NTH (fstatfs, (int __fildes, struct statfs *__buf),
 #endif
 
 extern __typeof(fstatfs) __libc_fstatfs attribute_hidden;
+#ifdef __NR_fstatfs
 #define __NR___libc_fstatfs __NR_fstatfs
 _syscall2(int, __libc_fstatfs, int, fd, struct statfs *, buf)
+#else
+/* Backwards compatibility for __libc_fstatfs */
+int __libc_fstatfs (int __fildes, struct statfs *__buf)
+{
+	struct statfs64 b;
+	int err;
+
+	/*
+	 * Check if __buf has a sane value.
+	 * This does not prevent the user from passing
+	 * an artitrary possitive value that can lead to
+	 * segfault or other security problems
+	 */
+	if ( __buf == NULL || (int)__buf < 0) {
+		__set_errno(EFAULT);
+		return -1;
+	}
+
+	err = INLINE_SYSCALL(fstatfs64, 3, __fildes, sizeof(b), &b);
+
+	if (err < 0)
+		return -1;
+
+	memset(__buf, 0x00, sizeof(*__buf));
+	__buf->f_type = b.f_type;
+	__buf->f_bsize = b.f_bsize;
+	__buf->f_blocks = b.f_blocks;
+	__buf->f_bfree = b.f_bfree;
+	__buf->f_bavail = b.f_bavail;
+	__buf->f_files = b.f_files;
+	__buf->f_ffree = b.f_ffree;
+	__buf->f_namelen = b.f_namelen;
+	__buf->f_frsize = b.f_frsize;
+	__buf->f_fsid = b.f_fsid;
+	memcpy(__buf->f_spare, b.f_spare, sizeof(b.f_spare));
+	return err;
+};
+/* Redefined fstatfs because we need it for backwards compatibility */
+#endif /* __NR_fstatfs */
 
 #if defined __UCLIBC_LINUX_SPECIFIC__
 weak_alias(__libc_fstatfs,fstatfs)
diff --git a/libc/sysdeps/linux/common/ftruncate.c b/libc/sysdeps/linux/common/ftruncate.c
index 3bdef3f..ca60f34 100644
--- a/libc/sysdeps/linux/common/ftruncate.c
+++ b/libc/sysdeps/linux/common/ftruncate.c
@@ -11,5 +11,14 @@
 #include <unistd.h>
 
 
+#if defined(__NR_ftruncate64) && ! defined(__NR_ftruncate)
+int ftruncate(int fd, __off_t length)
+{
+	return ftruncate64(fd, length);
+}
+libc_hidden_def(ftruncate);
+
+#else
 _syscall2(int, ftruncate, int, fd, __off_t, length)
 libc_hidden_def(ftruncate)
+#endif
diff --git a/libc/sysdeps/linux/common/getdents.c b/libc/sysdeps/linux/common/getdents.c
index 46f7b8e..9823e5d 100644
--- a/libc/sysdeps/linux/common/getdents.c
+++ b/libc/sysdeps/linux/common/getdents.c
@@ -44,10 +44,12 @@ struct kernel_dirent
 
 ssize_t __getdents (int fd, char *buf, size_t nbytes) attribute_hidden;
 
+#if defined(__NR_getdents)
 #define __NR___syscall_getdents __NR_getdents
 static __always_inline _syscall3(int, __syscall_getdents, int, fd, unsigned char *, kdirp, size_t, count)
+#endif
 
-#if defined __ASSUME_GETDENTS32_D_TYPE
+#if defined __ASSUME_GETDENTS32_D_TYPE && defined __NR_getdents
 
 ssize_t __getdents (int fd, char *buf, size_t nbytes)
 {
diff --git a/libc/sysdeps/linux/common/inotify.c b/libc/sysdeps/linux/common/inotify.c
index e2f3836..972896d 100644
--- a/libc/sysdeps/linux/common/inotify.c
+++ b/libc/sysdeps/linux/common/inotify.c
@@ -11,12 +11,18 @@
 #include <sys/syscall.h>
 #include <sys/inotify.h>
 
-#ifdef __NR_inotify_init
-_syscall0(int, inotify_init)
+#if defined(__NR_inotify_init1)
+_syscall1(int, inotify_init1, int, flags)
 #endif
 
-#ifdef __NR_inotify_init1
-_syscall1(int, inotify_init1, int, flags)
+#if defined(__NR_inotify_init1) && ! defined(__NR_inotify_init)
+int inotify_init(void)
+{
+	return INLINE_SYSCALL(inotify_init1, 1, 0);
+}
+
+#else
+_syscall0(int, inotify_init)
 #endif
 
 #ifdef __NR_inotify_add_watch
diff --git a/libc/sysdeps/linux/common/lchown.c b/libc/sysdeps/linux/common/lchown.c
index c0f8ce7..5cc62a2 100644
--- a/libc/sysdeps/linux/common/lchown.c
+++ b/libc/sysdeps/linux/common/lchown.c
@@ -8,9 +8,18 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <bits/wordsize.h>
 
+#if defined(__NR_fchownat) && ! defined(__NR_lchown)
+int lchown(const char* path, uid_t owner, gid_t group)
+{
+	return fchownat(AT_FDCWD, path, owner, group, AT_SYMLINK_NOFOLLOW);
+}
+
+#else
+
 #if (__WORDSIZE == 32 && defined(__NR_lchown32)) || __WORDSIZE == 64
 # ifdef __NR_lchown32
 #  undef __NR_lchown
@@ -36,3 +45,5 @@ int lchown(const char *path, uid_t owner, gid_t group)
 }
 
 #endif
+
+#endif
diff --git a/libc/sysdeps/linux/common/link.c b/libc/sysdeps/linux/common/link.c
index b5e5536..9cc197a 100644
--- a/libc/sysdeps/linux/common/link.c
+++ b/libc/sysdeps/linux/common/link.c
@@ -8,5 +8,14 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
+
+#if defined(__NR_linkat) && ! defined(__NR_link)
+int link(const char* oldpath, const char* newpath)
+{
+	return linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0);
+}
+#else
 _syscall2(int, link, const char *, oldpath, const char *, newpath)
+#endif
diff --git a/libc/sysdeps/linux/common/llseek.c b/libc/sysdeps/linux/common/llseek.c
index ff16917..3ca05d8 100644
--- a/libc/sysdeps/linux/common/llseek.c
+++ b/libc/sysdeps/linux/common/llseek.c
@@ -16,13 +16,18 @@
 # define __NR__llseek __NR_llseek
 #endif
 
-#if defined __NR__llseek && defined __UCLIBC_HAS_LFS__
+#if (defined __NR__llseek ||defined __NR_llseek) && defined __UCLIBC_HAS_LFS__
 
 loff_t lseek64(int fd, loff_t offset, int whence)
 {
 	loff_t result;
+#if defined(__NR_llseek)
+	return (loff_t)(INLINE_SYSCALL(llseek, 5, fd, (off_t)(offset >> 32),
+		(off_t)(offset & 0xffffffff), &result, whence) ? : result);
+#else
 	return (loff_t)(INLINE_SYSCALL(_llseek, 5, fd, (off_t) (offset >> 32),
 				(off_t) (offset & 0xffffffff), &result, whence) ?: result);
+#endif
 }
 
 #else
diff --git a/libc/sysdeps/linux/common/lstat.c b/libc/sysdeps/linux/common/lstat.c
index db72d1f..753dc4e 100644
--- a/libc/sysdeps/linux/common/lstat.c
+++ b/libc/sysdeps/linux/common/lstat.c
@@ -8,10 +8,20 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <sys/stat.h>
 #include "xstatconv.h"
 
+#if defined(__NR_fstatat64) && ! defined(__NR_lstat)
+int lstat(const char* file_name, struct stat* buf)
+{
+	return fstatat(AT_FDCWD, file_name, buf, AT_SYMLINK_NOFOLLOW);
+}
+libc_hidden_def(lstat)
+
+/* For systems which have both, prefer the old one */
+#else
 int lstat(const char *file_name, struct stat *buf)
 {
 	int result;
@@ -33,12 +43,15 @@ int lstat(const char *file_name, struct stat *buf)
 	if (result == 0) {
 		__xstat_conv(&kbuf, buf);
 	}
-#endif
+#endif /* __NR_lstat64 */
 	return result;
 }
 libc_hidden_def(lstat)
 
-#if ! defined __NR_lstat64 && defined __UCLIBC_HAS_LFS__
+#if ! defined __NR_fstatat64 && ! defined __NR_lstat64 \
+	&& defined __UCLIBC_HAS_LFS__
 strong_alias_untyped(lstat,lstat64)
 libc_hidden_def(lstat64)
 #endif
+
+#endif /* __NR_fstatat64 */
diff --git a/libc/sysdeps/linux/common/lstat64.c b/libc/sysdeps/linux/common/lstat64.c
index 235b76d..9717335 100644
--- a/libc/sysdeps/linux/common/lstat64.c
+++ b/libc/sysdeps/linux/common/lstat64.c
@@ -9,12 +9,22 @@
 
 #include <sys/syscall.h>
 
-#if defined __UCLIBC_HAS_LFS__ && defined __NR_lstat64
+#if defined __UCLIBC_HAS_LFS__
+# include <fcntl.h>
 # include <unistd.h>
 # include <sys/stat.h>
 # include "xstatconv.h"
 
 
+#if defined(__NR_fstatat64) && ! defined(__NR_lstat64)
+int lstat64(const char* file_name, struct stat64* buf)
+{
+	return fstatat64(AT_FDCWD, file_name, buf, AT_SYMLINK_NOFOLLOW);
+}
+libc_hidden_def(lstat64)
+
+/* For systems which have both, prefer the old one */
+#elif defined(__NR_lstat64)
 # define __NR___syscall_lstat64 __NR_lstat64
 static __inline__ _syscall2(int, __syscall_lstat64, const char *, file_name,
 		  struct kernel_stat64 *, buf)
@@ -33,3 +43,5 @@ int lstat64(const char *file_name, struct stat64 *buf)
 libc_hidden_def(lstat64)
 
 #endif
+
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/common/mkdir.c b/libc/sysdeps/linux/common/mkdir.c
index fbc587d..b7f025d 100644
--- a/libc/sysdeps/linux/common/mkdir.c
+++ b/libc/sysdeps/linux/common/mkdir.c
@@ -9,8 +9,15 @@
 
 #include <sys/syscall.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 
+#if defined(__NR_mkdirat) && ! defined(__NR_mkdir)
+int mkdir(const char* pathname, mode_t mode)
+{
+	return mkdirat(AT_FDCWD, pathname, mode);
+}
 
+#else
 #define __NR___syscall_mkdir __NR_mkdir
 static __inline__ _syscall2(int, __syscall_mkdir, const char *, pathname,
 		__kernel_mode_t, mode)
@@ -19,4 +26,5 @@ int mkdir(const char *pathname, mode_t mode)
 {
 	return (__syscall_mkdir(pathname, mode));
 }
+#endif
 libc_hidden_def(mkdir)
diff --git a/libc/sysdeps/linux/common/mknod.c b/libc/sysdeps/linux/common/mknod.c
index b52c8c5..55a4436 100644
--- a/libc/sysdeps/linux/common/mknod.c
+++ b/libc/sysdeps/linux/common/mknod.c
@@ -9,7 +9,14 @@
 
 #include <sys/syscall.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 
+#if defined(__NR_mknodat) && ! defined(__NR_mknod)
+int mknod(const char* path, mode_t mode, dev_t dev)
+{
+	return mknodat(AT_FDCWD, path, mode, dev);
+}
+#else
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
 	unsigned long long int k_dev;
@@ -19,4 +26,5 @@ int mknod(const char *path, mode_t mode, dev_t dev)
 
 	return INLINE_SYSCALL(mknod, 3, path, mode, (unsigned int)k_dev);
 }
+#endif
 libc_hidden_def(mknod)
diff --git a/libc/sysdeps/linux/common/not-cancel.h b/libc/sysdeps/linux/common/not-cancel.h
index 9418417..c5ef988 100644
--- a/libc/sysdeps/linux/common/not-cancel.h
+++ b/libc/sysdeps/linux/common/not-cancel.h
@@ -21,10 +21,17 @@
 #include <sysdep.h>
 
 /* Uncancelable open.  */
+#if defined(__NR_openat) && ! defined(__NR_open)
+#define open_not_cancel(name, flags, mode) \
+   INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), (flags), (mode))
+#define open_not_cancel_2(name, flags) \
+   INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), (flags))
+#else
 #define open_not_cancel(name, flags, mode) \
    INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
 #define open_not_cancel_2(name, flags) \
    INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+#endif
 
 /* Uncancelable close.  */
 #define close_not_cancel(fd) \
diff --git a/libc/sysdeps/linux/common/open-wrapper.c b/libc/sysdeps/linux/common/open-wrapper.c
new file mode 100644
index 0000000..2ad12b6
--- /dev/null
+++ b/libc/sysdeps/linux/common/open-wrapper.c
@@ -0,0 +1,77 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * open() for uClibc
+ *
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <sys/syscall.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/param.h>
+
+#if defined(__NR_open)
+#define __NR___syscall_open __NR_open
+static __inline__ _syscall3(int, __syscall_open, const char *, file,
+		int, flags, __kernel_mode_t, mode)
+#endif
+
+/* NPTL has its own implementation */
+#if ! defined(__UCLIBC_HAS_THREADS_NATIVE__)
+int open(const char *file, int oflag, ...)
+{
+	mode_t mode = 0;
+
+	if (oflag & O_CREAT) {
+		va_list arg;
+		va_start(arg, oflag);
+		mode = va_arg(arg, mode_t);
+		va_end(arg);
+	}
+#if defined(__NR_openat) && ! defined(__NR_open)
+	return openat(AT_FDCWD, file, oflag, mode);
+#else
+	return __syscall_open(file, oflag, mode);
+#endif
+}
+
+#else
+#if defined(__NR_openat) && ! defined(__NR_open)
+/*
+ * Arches that don't support the open() syscall, need to
+ * define a symbol for that so other packages that rely
+ * on it, can build and run successfully
+ */
+int open(const char *file, int oflag, ...)
+{
+	mode_t mode = 0;
+
+	va_list arg;
+	va_start(arg, oflag);
+	mode = va_arg(arg, mode_t);
+	va_end(arg);
+
+	return openat(AT_FDCWD, file, oflag, mode);
+}
+
+#else
+/*
+ * The implementation for open() is defined in the NTPL source files.
+ * We must not define it here, to avoid symbol collisions
+ */
+#endif
+
+#endif /* __UCLIBC_HAS_THREADS_NATIVE__ */
+
+#ifdef __LINUXTHREADS_NEW__
+libc_hidden_def(open)
+#elif defined(__LINUXTHREADS_OLD__) || \
+( defined(__UCLIBC_HAS_THREADS_NATIVE__) && defined(__NR_openat) \
+&& ! defined(__NR_open) )
+libc_hidden_weak(open)
+strong_alias(open,__libc_open)
+#endif
diff --git a/libc/sysdeps/linux/common/open.c b/libc/sysdeps/linux/common/open.c
deleted file mode 100644
index 9fb694d..0000000
--- a/libc/sysdeps/linux/common/open.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * open() for uClibc
- *
- * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
- *
- * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
- */
-
-#include <sys/syscall.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <fcntl.h>
-#include <string.h>
-#include <sys/param.h>
-
-#define __NR___syscall_open __NR_open
-static __inline__ _syscall3(int, __syscall_open, const char *, file,
-		int, flags, __kernel_mode_t, mode)
-
-int open(const char *file, int oflag, ...)
-{
-	mode_t mode = 0;
-
-	if (oflag & O_CREAT) {
-		va_list arg;
-		va_start(arg, oflag);
-		mode = va_arg(arg, mode_t);
-		va_end(arg);
-	}
-
-	return __syscall_open(file, oflag, mode);
-}
-#ifndef __LINUXTHREADS_OLD__
-libc_hidden_def(open)
-#else
-libc_hidden_weak(open)
-strong_alias(open,__libc_open)
-#endif
diff --git a/libc/sysdeps/linux/common/open64.c b/libc/sysdeps/linux/common/open64.c
index c1f5400..675f8e1 100644
--- a/libc/sysdeps/linux/common/open64.c
+++ b/libc/sysdeps/linux/common/open64.c
@@ -34,11 +34,18 @@ int open64 (const char *file, int oflag, ...)
 
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
   if (SINGLE_THREAD_P)
+#if defined(__NR_openat) && ! defined(__NR_open)
+    return INLINE_SYSCALL (openat, 4, AT_FDCWD, file, oflag | O_LARGEFILE, mode);
+#else
     return INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+#endif
 
   int oldtype = LIBC_CANCEL_ASYNC ();
-
+#if defined(__NR_openat) && ! defined(__NR_open)
+  int result = INLINE_SYSCALL (openat, 4, AT_FDCWD, file, oflag | O_LARGEFILE, mode);
+#else
   int result = INLINE_SYSCALL (open, 3, file, oflag | O_LARGEFILE, mode);
+#endif
 
   LIBC_CANCEL_RESET (oldtype);
 
diff --git a/libc/sysdeps/linux/common/pause.c b/libc/sysdeps/linux/common/pause.c
index ab16fa7..036f6a3 100644
--- a/libc/sysdeps/linux/common/pause.c
+++ b/libc/sysdeps/linux/common/pause.c
@@ -34,6 +34,7 @@ __libc_pause (void)
   return sigsuspend (&set);
 }
 weak_alias (__libc_pause, pause)
+weak_alias (__libc_pause, __pause_nocancel)
 
 #ifdef __UCLIBC_HAS_THREADS_NATIVE__
 LIBC_CANCEL_HANDLED ();		/* sigsuspend handles our cancellation.  */
diff --git a/libc/sysdeps/linux/common/pipe.c b/libc/sysdeps/linux/common/pipe.c
index 8eae27c..5c0ad25 100644
--- a/libc/sysdeps/linux/common/pipe.c
+++ b/libc/sysdeps/linux/common/pipe.c
@@ -11,5 +11,13 @@
 #include <unistd.h>
 
 
+#if defined(__NR_pipe2) && ! defined(__NR_pipe)
+int pipe(int filedes[2])
+{
+	return pipe2(filedes, 0);
+}
+/* If both are defined then use the pipe syscall */
+#else
 _syscall1(int, pipe, int *, filedes)
+#endif
 libc_hidden_def(pipe)
diff --git a/libc/sysdeps/linux/common/pread_write.c b/libc/sysdeps/linux/common/pread_write.c
index 88e6957..fd9c426 100644
--- a/libc/sysdeps/linux/common/pread_write.c
+++ b/libc/sysdeps/linux/common/pread_write.c
@@ -17,6 +17,12 @@
 #include <unistd.h>
 #include <stdint.h>
 #include <endian.h>
+#include <sysdep-cancel.h>
+
+#ifndef __UCLIBC_HAS_THREADS_NATIVE__
+#define LIBC_CANCEL_ASYNC() 0
+#define LIBC_CANCEL_RESET(X)
+#endif
 
 extern __typeof(pread) __libc_pread;
 extern __typeof(pwrite) __libc_pwrite;
@@ -35,7 +41,14 @@ static __inline__ _syscall5(ssize_t, __syscall_pread, int, fd, void *, buf,
 
 ssize_t __libc_pread(int fd, void *buf, size_t count, off_t offset)
 {
-	return __syscall_pread(fd, buf, count, __LONG_LONG_PAIR(offset >> 31, offset));
+	if (SINGLE_THREAD_P)
+		return __syscall_pread(fd, buf, count,
+		__LONG_LONG_PAIR(offset >> 31, offset));
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __syscall_pread(fd, buf, count,
+		__LONG_LONG_PAIR(offset >> 31, offset));
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pread,pread)
 
@@ -44,7 +57,14 @@ ssize_t __libc_pread64(int fd, void *buf, size_t count, off64_t offset)
 {
 	uint32_t low = offset & 0xffffffff;
 	uint32_t high = offset >> 32;
-	return __syscall_pread(fd, buf, count, __LONG_LONG_PAIR(high, low));
+	if (SINGLE_THREAD_P)
+		return __syscall_pread(fd, buf, count,
+			__LONG_LONG_PAIR(high, low));
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __syscall_pread(fd, buf, count,
+			__LONG_LONG_PAIR(high, low));
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pread64,pread64)
 # endif /* __UCLIBC_HAS_LFS__  */
@@ -59,7 +79,14 @@ static __inline__ _syscall5(ssize_t, __syscall_pwrite, int, fd, const void *, bu
 
 ssize_t __libc_pwrite(int fd, const void *buf, size_t count, off_t offset)
 {
-	return __syscall_pwrite(fd, buf, count, __LONG_LONG_PAIR(offset >> 31, offset));
+	if (SINGLE_THREAD_P)
+		return __syscall_pwrite(fd, buf, count,
+		__LONG_LONG_PAIR(offset >> 31, offset));
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __syscall_pwrite(fd, buf, count,
+		__LONG_LONG_PAIR(offset >> 31, offset));
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pwrite,pwrite)
 
@@ -68,7 +95,14 @@ ssize_t __libc_pwrite64(int fd, const void *buf, size_t count, off64_t offset)
 {
 	uint32_t low = offset & 0xffffffff;
 	uint32_t high = offset >> 32;
-	return __syscall_pwrite(fd, buf, count, __LONG_LONG_PAIR(high, low));
+	if (SINGLE_THREAD_P)
+		return __syscall_pwrite(fd, buf, count,
+			__LONG_LONG_PAIR(high, low));
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __syscall_pwrite(fd, buf, count,
+			__LONG_LONG_PAIR(high, low));
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pwrite64,pwrite64)
 # endif /* __UCLIBC_HAS_LFS__  */
@@ -155,14 +189,24 @@ static ssize_t __fake_pread_write64(int fd, void *buf,
 #ifndef __NR_pread
 ssize_t __libc_pread(int fd, void *buf, size_t count, off_t offset)
 {
-	return __fake_pread_write(fd, buf, count, offset, 0);
+	if (SINGLE_THREAD_P)
+		return __fake_pread_write(fd, buf, count, offset, 0);
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __fake_pread_write(fd, buf, count, offset, 0);
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pread,pread)
 
 # ifdef __UCLIBC_HAS_LFS__
 ssize_t __libc_pread64(int fd, void *buf, size_t count, off64_t offset)
 {
-	return __fake_pread_write64(fd, buf, count, offset, 0);
+	if (SINGLE_THREAD_P)
+		return __fake_pread_write64(fd, buf, count, offset, 0);
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __fake_pread_write64(fd, buf, count, offset, 0);
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pread64,pread64)
 # endif /* __UCLIBC_HAS_LFS__  */
@@ -173,14 +217,24 @@ ssize_t __libc_pwrite(int fd, const void *buf, size_t count, off_t offset)
 {
 	/* we won't actually be modifying the buffer,
 	 *just cast it to get rid of warnings */
-	return __fake_pread_write(fd, (void*)buf, count, offset, 1);
+	if (SINGLE_THREAD_P)
+		return __fake_pread_write(fd, (void*)buf, count, offset, 1);
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __fake_pread_write(fd, (void*)buf, count, offset, 1);
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pwrite,pwrite)
 
 # ifdef __UCLIBC_HAS_LFS__
 ssize_t __libc_pwrite64(int fd, const void *buf, size_t count, off64_t offset)
 {
-	return __fake_pread_write64(fd, (void*)buf, count, offset, 1);
+	if (SINGLE_THREAD_P)
+		return __fake_pread_write64(fd, (void*)buf, count, offset, 1);
+	int oldtype = LIBC_CANCEL_ASYNC();
+	ssize_t result = __fake_pread_write64(fd, (void*)buf, count, offset, 1);
+	LIBC_CANCEL_RESET(oldtype);
+	return result;
 }
 weak_alias(__libc_pwrite64,pwrite64)
 # endif /* __UCLIBC_HAS_LFS__  */
diff --git a/libc/sysdeps/linux/common/readlink.c b/libc/sysdeps/linux/common/readlink.c
index ef9e835..5ecbd3a 100644
--- a/libc/sysdeps/linux/common/readlink.c
+++ b/libc/sysdeps/linux/common/readlink.c
@@ -8,7 +8,15 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 
+#if defined(__NR_readlinkat) && ! defined(__NR_readlink)
+ssize_t readlink (const char* path, char* buf, size_t len)
+{
+	return readlinkat(AT_FDCWD, path, buf, len);
+}
+#else
 _syscall3(ssize_t, readlink, const char *, path, char *, buf, size_t, bufsiz)
+#endif
 libc_hidden_def(readlink)
diff --git a/libc/sysdeps/linux/common/rename.c b/libc/sysdeps/linux/common/rename.c
index 9d8397a..05f1411 100644
--- a/libc/sysdeps/linux/common/rename.c
+++ b/libc/sysdeps/linux/common/rename.c
@@ -8,11 +8,18 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/param.h>
 #include <stdio.h>
 
+#if defined(__NR_renameat) && ! defined(__NR_rename)
+int rename(const char* oldpath, const char* newpath)
+{
+	return renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath);
+}
+#else
 #define __NR___syscall_rename __NR_rename
 static __inline__ _syscall2(int, __syscall_rename, const char *, oldpath,
 		const char *, newpath)
@@ -21,4 +28,4 @@ int rename(const char * oldpath, const char * newpath)
 {
 	return __syscall_rename(oldpath, newpath);
 }
-
+#endif
diff --git a/libc/sysdeps/linux/common/rmdir.c b/libc/sysdeps/linux/common/rmdir.c
index bad6654..9161819 100644
--- a/libc/sysdeps/linux/common/rmdir.c
+++ b/libc/sysdeps/linux/common/rmdir.c
@@ -8,8 +8,16 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 
 
+#if defined(__NR_unlinkat) && ! defined(__NR_rmdir)
+int rmdir(const char* pathname)
+{
+	return unlinkat(AT_FDCWD, pathname, AT_REMOVEDIR);
+}
+#else
 _syscall1(int, rmdir, const char *, pathname)
+#endif
 libc_hidden_def(rmdir)
diff --git a/libc/sysdeps/linux/common/sched_setaffinity.c b/libc/sysdeps/linux/common/sched_setaffinity.c
index 980c441..bd5a26e 100644
--- a/libc/sysdeps/linux/common/sched_setaffinity.c
+++ b/libc/sysdeps/linux/common/sched_setaffinity.c
@@ -41,10 +41,11 @@ int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
 	if (unlikely (__kernel_cpumask_size == 0)) {
 		INTERNAL_SYSCALL_DECL (err);
 		int res;
+		pid_t _pid = getpid();
 		size_t psize = 128;
 		void *p = alloca (psize);
 
-		while (res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, getpid (),
+		while (res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, _pid,
 					       psize, p),
 		       INTERNAL_SYSCALL_ERROR_P (res, err)
 		       && INTERNAL_SYSCALL_ERRNO (res, err) == EINVAL)
diff --git a/libc/sysdeps/linux/common/sendfile.c b/libc/sysdeps/linux/common/sendfile.c
index 89bab9f..c80df6e 100644
--- a/libc/sysdeps/linux/common/sendfile.c
+++ b/libc/sysdeps/linux/common/sendfile.c
@@ -8,16 +8,54 @@
  */
 
 #include <sys/syscall.h>
+#include <stddef.h>
 #include <unistd.h>
 #include <sys/sendfile.h>
 
-#ifdef __NR_sendfile
+#if defined(__NR_sendfile64) && ! defined(__NR_sendfile)
+ssize_t sendfile(int out_fd, int in_fd, __off_t* offset, size_t count)
+{
+	__off64_t off64, *off;
+	ssize_t res;
 
+	/*
+	 * Check if valids fd and valid pointers were passed
+	 * This does not prevent the user from passing
+	 * an arbitrary pointer causing a segfault or
+	 * other security issues
+	 */
+
+	if (in_fd < 0 || out_fd < 0) {
+		__set_errno(EBADF);
+		return -1;
+	}
+
+	if (offset == NULL || (int)offset < 0) {
+		__set_errno(EFAULT);
+		return -1;
+	}
+
+	if (offset) {
+		off = &off64;
+		off64 = *offset;
+	} else {
+		off = NULL;
+	}
+
+	res = INLINE_SYSCALL(sendfile64, 4, out_fd, in_fd, off, count);
+
+	if (res >= 0)
+		*offset = off64;
+
+	return res;
+}
+
+#elif defined(__NR_sendfile)
 _syscall4(ssize_t, sendfile, int, out_fd, int, in_fd, __off_t *, offset,
 		  size_t, count)
 
-#if ! defined __NR_sendfile64 && defined __UCLIBC_HAS_LFS__
+#if ! defined(__NR_sendfile64) && defined(__UCLIBC_HAS_LFS__)
 strong_alias(sendfile,sendfile64)
 #endif
 
-#endif /* __NR_sendfile */
+#endif
diff --git a/libc/sysdeps/linux/common/stat.c b/libc/sysdeps/linux/common/stat.c
index 829f35a..88e1fa8 100644
--- a/libc/sysdeps/linux/common/stat.c
+++ b/libc/sysdeps/linux/common/stat.c
@@ -8,12 +8,21 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <sys/stat.h>
 #include "xstatconv.h"
 
 #undef stat
 
+#if defined(__NR_fstat64) && ! defined(__NR_stat)
+int stat(const char* file_name, struct stat* buf)
+{
+	return fstatat(AT_FDCWD, file_name, buf, 0);
+}
+
+#else
+
 int stat(const char *file_name, struct stat *buf)
 {
 	int result;
@@ -35,12 +44,14 @@ int stat(const char *file_name, struct stat *buf)
 	if (result == 0) {
 		__xstat_conv(&kbuf, buf);
 	}
-#endif
+#endif /* __NR_stat64 */
 	return result;
 }
+#endif /* __NR_fstat64 */
 libc_hidden_def(stat)
 
-#if ! defined __NR_stat64 && defined __UCLIBC_HAS_LFS__
+#if ! defined __NR_stat64 && ! defined __NR_fstatat64 && \
+	defined __UCLIBC_HAS_LFS__
 strong_alias_untyped(stat,stat64)
 libc_hidden_def(stat64)
-#endif
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/common/stat64.c b/libc/sysdeps/linux/common/stat64.c
index a76f182..52e82ec 100644
--- a/libc/sysdeps/linux/common/stat64.c
+++ b/libc/sysdeps/linux/common/stat64.c
@@ -9,11 +9,21 @@
 
 #include <sys/syscall.h>
 #include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
 
-#if defined __UCLIBC_HAS_LFS__ && defined __NR_stat64
+#if defined __UCLIBC_HAS_LFS__
 
+#if defined(__NR_fstatat64) && ! defined(__NR_stat64)
+int stat64(const char* file_name, struct stat64* buf)
+{
+	return fstatat64(AT_FDCWD, file_name, buf, 0);
+}
+libc_hidden_def(stat64)
+
+/* For systems which have both, prefer the old one */
+#elif defined(__NR_stat64)
 # define __NR___syscall_stat64 __NR_stat64
-# include <unistd.h>
 # include "xstatconv.h"
 
 static __inline__ _syscall2(int, __syscall_stat64,
@@ -32,3 +42,5 @@ int stat64(const char *file_name, struct stat64 *buf)
 }
 libc_hidden_def(stat64)
 #endif
+
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/common/statfs.c b/libc/sysdeps/linux/common/statfs.c
index d24bc9d..9f96b4d 100644
--- a/libc/sysdeps/linux/common/statfs.c
+++ b/libc/sysdeps/linux/common/statfs.c
@@ -12,7 +12,54 @@
 #include <sys/param.h>
 #include <sys/vfs.h>
 
+#if defined(__NR_statfs64) && ! defined(__NR_statfs)
+
+int __libc_statfs(const char* path, struct statfs* buf)
+{
+	struct statfs64 b;
+	int err;
+
+	/*
+	 * See if pointer has a sane value.
+	 * This does not prevent the user from
+	 * passing an arbitrary possitive value
+	 * that can lead to a segfault or potential
+	 * security problems
+	 */
+
+	if (buf == NULL || (int)buf < 0) {
+		__set_errno(EFAULT);
+		return -1;
+	}
+
+	err = INLINE_SYSCALL(statfs64, 3, path, sizeof(b), &b);
+
+	if (err < 0)
+		return -1;
+
+	buf->f_type = b.f_type;
+	buf->f_bsize = b.f_bsize;
+	buf->f_blocks = b.f_blocks;
+	buf->f_bfree = b.f_bfree;
+	buf->f_bavail = b.f_bavail;
+	buf->f_files = b.f_files;
+	buf->f_ffree = b.f_ffree;
+	buf->f_namelen = b.f_namelen;
+	buf->f_frsize = b.f_frsize;
+	buf->f_fsid = b.f_fsid;
+	memcpy(buf->f_spare, b.f_spare, sizeof(b.f_spare));
+
+	return err;
+}
+#if defined __UCLIBC_LINUX_SPECIFIC__ || defined __UCLIBC_HAS_THREADS_NATIVE__
+/* statfs is used by NPTL, so it must exported in case */
+weak_alias(__libc_statfs,statfs)
+#endif
+
+/* For systems which have both, prefer the old one */
+#else
 extern __typeof(statfs) __libc_statfs attribute_hidden;
+
 #define __NR___libc_statfs __NR_statfs
 _syscall2(int, __libc_statfs, const char *, path, struct statfs *, buf)
 
@@ -20,3 +67,5 @@ _syscall2(int, __libc_statfs, const char *, path, struct statfs *, buf)
 /* statfs is used by NPTL, so it must exported in case */
 weak_alias(__libc_statfs,statfs)
 #endif
+
+#endif
diff --git a/libc/sysdeps/linux/common/symlink.c b/libc/sysdeps/linux/common/symlink.c
index e53e8d4..9632fa3 100644
--- a/libc/sysdeps/linux/common/symlink.c
+++ b/libc/sysdeps/linux/common/symlink.c
@@ -9,6 +9,19 @@
 
 #include <sys/syscall.h>
 #if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K
+#include <fcntl.h>
 #include <unistd.h>
+
+#if defined(__NR_symlinkat) && ! defined(__NR_symlink)
+int symlink(const char* oldpath, const char* newpath)
+{
+	return symlinkat(oldpath, AT_FDCWD, newpath);
+}
+
+#else
+
 _syscall2(int, symlink, const char *, oldpath, const char *, newpath)
+
+#endif
+
 #endif
diff --git a/libc/sysdeps/linux/common/truncate.c b/libc/sysdeps/linux/common/truncate.c
index 2331bdd..727db12 100644
--- a/libc/sysdeps/linux/common/truncate.c
+++ b/libc/sysdeps/linux/common/truncate.c
@@ -11,5 +11,14 @@
 #include <unistd.h>
 
 
+#if defined(__NR_truncate64) && ! defined(__NR_truncate)
+int truncate(const char* path, __off_t length)
+{
+	return truncate64(path, length);
+}
+libc_hidden_def(truncate);
+
+#else
 _syscall2(int, truncate, const char *, path, __off_t, length)
 libc_hidden_def(truncate)
+#endif
diff --git a/libc/sysdeps/linux/common/unlink.c b/libc/sysdeps/linux/common/unlink.c
index 513cdd5..a3af6c5 100644
--- a/libc/sysdeps/linux/common/unlink.c
+++ b/libc/sysdeps/linux/common/unlink.c
@@ -8,8 +8,16 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
 #include <unistd.h>
 
 
+#if defined(__NR_unlinkat) && ! defined(__NR_unlink)
+int unlink(const char* pathname)
+{
+	return unlinkat(AT_FDCWD, pathname, 0);
+}
+#else
 _syscall1(int, unlink, const char *, pathname)
+#endif
 libc_hidden_def(unlink)
diff --git a/libc/sysdeps/linux/common/ustat.c b/libc/sysdeps/linux/common/ustat.c
index e97fa76..b89b4c9 100644
--- a/libc/sysdeps/linux/common/ustat.c
+++ b/libc/sysdeps/linux/common/ustat.c
@@ -9,8 +9,22 @@
 
 #include <sys/syscall.h>
 #include <sys/ustat.h>
+#include <sys/vfs.h>
 #include <sys/sysmacros.h>
+#include <string.h>
 
+#if ! defined(__NR_ustat)
+/*
+ * ustat syscall is deprecated and statfs or fstatfs should
+ * be used instead. There is no way to provide a wrapper for the
+ * newer syscalls, so just mark this syscall as unimplemented
+ */
+int ustat(dev_t dev, struct ustat* ubuf)
+{
+	__set_errno (ENOSYS);
+	return -1;
+}
+#else
 #define __NR___syscall_ustat __NR_ustat
 /* Kernel's fs/super.c defines this:
  * long sys_ustat(unsigned dev, struct ustat __user * ubuf),
@@ -24,3 +38,4 @@ int ustat(dev_t dev, struct ustat *ubuf)
 {
 	return __syscall_ustat(dev, ubuf);
 }
+#endif
diff --git a/libc/sysdeps/linux/common/utime.c b/libc/sysdeps/linux/common/utime.c
index c9fd1bf..d3e12d4 100644
--- a/libc/sysdeps/linux/common/utime.c
+++ b/libc/sysdeps/linux/common/utime.c
@@ -8,10 +8,30 @@
  */
 
 #include <sys/syscall.h>
+#include <fcntl.h>
+#include <stddef.h>
 #include <utime.h>
 
 
-#ifdef __NR_utime
+#if defined(__NR_utimensat) && ! defined(__NR_utime)
+int utime(const char* file, const struct utimbuf* times)
+{
+	struct timespec tspecs[2], *ts;
+
+	if (times) {
+		ts = tspecs;
+		ts[0].tv_sec = times->actime;
+		ts[0].tv_nsec = 0;
+		ts[1].tv_sec = times->modtime;
+		ts[1].tv_nsec = 0;
+	} else {
+		ts = NULL;
+	}
+
+	return utimensat(AT_FDCWD, file, ts, 0);
+}
+
+#elif defined(__NR_utime)
 _syscall2(int, utime, const char *, file, const struct utimbuf *, times)
 #else
 #include <stdlib.h>
diff --git a/libc/sysdeps/linux/common/utimes.c b/libc/sysdeps/linux/common/utimes.c
index 99d9202..2946fa7 100644
--- a/libc/sysdeps/linux/common/utimes.c
+++ b/libc/sysdeps/linux/common/utimes.c
@@ -8,11 +8,30 @@
  */
 
 #include <sys/syscall.h>
-#include <utime.h>
 #include <sys/time.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <stddef.h>
+
+
+#if defined(__NR_utimensat) && ! defined(__NR_utimes)
+int utimes(const char* file, const struct timeval tvp[2])
+{
+	struct timespec ts[2], *times;
+	if (tvp) {
+		times = ts;
+		times[0].tv_sec = tvp[0].tv_sec;
+		times[0].tv_nsec = tvp[0].tv_usec * 1000;
+		times[1].tv_sec = tvp[1].tv_sec;
+		times[1].tv_nsec = tvp[1].tv_usec * 1000;
+	} else {
+		times = NULL;
+	}
 
+	return utimensat(AT_FDCWD, file, times, 0);
+}
 
-#ifdef __NR_utimes
+#elif defined(__NR_utimes)
 _syscall2(int, utimes, const char *, file, const struct timeval *, tvp)
 #else
 #include <stdlib.h>
diff --git a/libc/sysdeps/linux/common/vfork.c b/libc/sysdeps/linux/common/vfork.c
index e7c9208..16f5f79 100644
--- a/libc/sysdeps/linux/common/vfork.c
+++ b/libc/sysdeps/linux/common/vfork.c
@@ -4,13 +4,31 @@
  * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
  */
 
+#include <signal.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/syscall.h>
 
 extern __typeof(vfork) __vfork attribute_hidden;
 
-#ifdef __NR_vfork
+#if defined(__NR_clone) && ! defined(__NR_vfork)
+pid_t __vfork(void)
+{
+	pid_t pid;
+	pid = INLINE_SYSCALL(clone, 4, CLONE_VFORK | CLONE_VM |
+		SIGCHLD, NULL, NULL, NULL);
+
+	if (pid<0) {
+		__set_errno(-pid);
+		return -1
+	}
+
+	return pid;
+}
+weak_alias(__vfork,vfork)
+libc_hidden_weak(vfork)
+
+#elif defined(__NR_vfork)
 
 # define __NR___vfork __NR_vfork
 _syscall0(pid_t, __vfork)
diff --git a/libc/sysdeps/linux/metag/Makefile b/libc/sysdeps/linux/metag/Makefile
new file mode 100644
index 0000000..633c91f
--- /dev/null
+++ b/libc/sysdeps/linux/metag/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir=../../../../
+top_builddir=../../../../
+all: objs
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
diff --git a/libc/sysdeps/linux/metag/Makefile.arch b/libc/sysdeps/linux/metag/Makefile.arch
new file mode 100644
index 0000000..4ea98b3
--- /dev/null
+++ b/libc/sysdeps/linux/metag/Makefile.arch
@@ -0,0 +1,14 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CSRC := brk.c syscall.c metag.c __syscall_error.c
+
+SSRC := _longjmp.S clone.S setjmp.S vfork.S
+
+ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
+SSRC += libc-metag_load_tp.S
+endif
diff --git a/libc/sysdeps/linux/metag/__syscall_error.c b/libc/sysdeps/linux/metag/__syscall_error.c
new file mode 100644
index 0000000..2b642e8
--- /dev/null
+++ b/libc/sysdeps/linux/metag/__syscall_error.c
@@ -0,0 +1,18 @@
+/* Wrapper for setting errno.
+ *
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <errno.h>
+#include <features.h>
+
+/* This routine is jumped to by all the syscall handlers, to stash
+ * an error number into errno.  */
+int __syscall_error(int err_no) attribute_hidden;
+int __syscall_error(int err_no)
+{
+	__set_errno(-err_no);
+	return -1;
+}
diff --git a/libc/sysdeps/linux/metag/_longjmp.S b/libc/sysdeps/linux/metag/_longjmp.S
new file mode 100644
index 0000000..4e6a99b
--- /dev/null
+++ b/libc/sysdeps/linux/metag/_longjmp.S
@@ -0,0 +1,22 @@
+!   Copyright (C) 2008 Imagination Technologies Ltd.
+
+        .text
+	.global	___longjmp
+	.type	___longjmp,function
+
+___longjmp:
+        !! If val is 0, set it to 1
+	CMP 	D0Ar2,#0
+	ADDZ	D0Ar2,D0Ar2,#1
+
+        !! Restore A0/A1 regs
+        MGETL   A0.0,A0.1,[D1Ar1++]
+        !! Restore D0/D1 regs
+	MOV 	A0.3,D1Ar1
+        MGETL   D0FrT,D0.5,D0.6,D0.7,[A0.3++]
+        !! Move 2nd argument to return value
+        MOV     D0Re0,D0Ar2
+        MOV     PC,D1RtP
+        .size   ___longjmp,.-___longjmp
+
+libc_hidden_def(__longjmp)
diff --git a/libc/sysdeps/linux/metag/bits/.cvsignore b/libc/sysdeps/linux/metag/bits/.cvsignore
new file mode 100644
index 0000000..8733825
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/.cvsignore
@@ -0,0 +1 @@
+sysnum.h
diff --git a/libc/sysdeps/linux/metag/bits/atomic.h b/libc/sysdeps/linux/metag/bits/atomic.h
new file mode 100644
index 0000000..2c5f2f7
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/atomic.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <sysdep.h>
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+void __metag_link_error (void);
+
+#define atomic_full_barrier() \
+     __asm__ __volatile__("": : :"memory")
+
+/* Atomic compare and exchange.  This sequence relies on the kernel to
+   provide a compare and exchange operation which is atomic. */
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  ({ __metag_link_error (); oldval; })
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  ({ __metag_link_error (); oldval; })
+
+/* This code uses the kernel helper to do cmpxchg. It relies on the fact
+   the helper code only clobbers D0Re0. */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)     \
+  ({ register __typeof (oldval) a_current __asm__ ("D1Ar1");		\
+    register __typeof (oldval) a_newval __asm__ ("D0Ar2") = (newval);   \
+    register __typeof (mem) a_ptr __asm__ ("D1Ar3") = (mem);            \
+    register __typeof (oldval) a_oldval __asm__ ("D0Ar4") = (oldval);	\
+    __asm__ __volatile__						\
+      ("0:\n\t"								\
+       "GETD	%[cur], [%[ptr]]\n\t"					\
+       "CMP	%[cur], %[old]\n\t"					\
+       "BNE	1f\n\t"							\
+       "MOVT	D1RtP, #0x6fff\n\t"					\
+       "ADD	D1RtP, D1RtP, #0xf040\n\t"				\
+       "SWAP	D1RtP, PC\n\t"						\
+       "MOV	%[cur], %[old]\n\t"					\
+       "CMP	D0Re0, #0\n\t"						\
+       "BNE	0b\n\t"							\
+       "1:"								\
+       : [cur] "=&r" (a_current)					\
+       : [new] "r" (a_newval), [ptr] "r" (a_ptr),			\
+	 [old] "r" (a_oldval)						\
+       : "D0Re0", "D1RtP", "cc", "memory");				\
+    a_current; })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({ __metag_link_error (); oldval; })
diff --git a/libc/sysdeps/linux/metag/bits/endian.h b/libc/sysdeps/linux/metag/bits/endian.h
new file mode 100644
index 0000000..f583334
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/endian.h
@@ -0,0 +1,7 @@
+/* META is little endian */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/libc/sysdeps/linux/metag/bits/fcntl.h b/libc/sysdeps/linux/metag/bits/fcntl.h
new file mode 100644
index 0000000..c4f641b
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/fcntl.h
@@ -0,0 +1,238 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995-1998, 2000, 2004, 2006, 2007, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECT	 040000	/* Direct disk access.	*/
+# define O_DIRECTORY	0200000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_NOATIME     01000000 /* Do not set atime.  */
+# define O_CLOEXEC     02000000 /* Set close_on_exec.  */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0100000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_UNIX98
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set on new fd.  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+#endif
+__END_DECLS
+
diff --git a/libc/sysdeps/linux/metag/bits/fenv.h b/libc/sysdeps/linux/metag/bits/fenv.h
new file mode 100644
index 0000000..4f6df1e
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/fenv.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+
+/* Define bits representing the exception.  We use the bit positions
+   of the appropriate bits in TXDEFR.  */
+enum
+  {
+    FE_INEXACT = 0x1,
+#define FE_INEXACT	FE_INEXACT
+    FE_UNDERFLOW = 0x2,
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 0x4,
+#define FE_OVERFLOW	FE_OVERFLOW
+    FE_DIVBYZERO = 0x8,
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_INVALID = 0x10,
+#define FE_INVALID	FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+/* The META FPU supports all of the four defined rounding modes.  We
+   use the values of the rounding mode bits in TXMODE as the values
+   for the appropriate macros.  */
+enum
+  {
+    FE_TONEAREST = 0x0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 0x1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_UPWARD = 0x2,
+#define FE_UPWARD	FE_UPWARD
+    FE_DOWNWARD = 0x3
+#define FE_DOWNWARD	FE_DOWNWARD
+  };
+
+
+/* Type representing exception flags.  */
+typedef unsigned int fexcept_t;
+
+
+/* Type representing floating-point environment.  */
+typedef struct
+  {
+    unsigned int txdefr;
+    unsigned int txmode;
+  }
+fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exception is masked.  */
+# define FE_NOMASK_ENV  ((__const fenv_t *) -2)
+#endif
diff --git a/libc/sysdeps/linux/metag/bits/ipc.h b/libc/sysdeps/linux/metag/bits/ipc.h
new file mode 100644
index 0000000..4852ade
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/ipc.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 1995-1999, 2000, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    __uid_t uid;			/* Owner's user ID.  */
+    __gid_t gid;			/* Owner's group ID.  */
+    __uid_t cuid;			/* Creator's user ID.  */
+    __gid_t cgid;			/* Creator's group ID.  */
+    unsigned int mode;			/* Read/write permission.  */
+    unsigned short __seq;		/* Sequence number.  */
+    unsigned short __pad1;
+    unsigned long __unused1;
+    unsigned long __unused2;
+  };
diff --git a/libc/sysdeps/linux/metag/bits/kernel_stat.h b/libc/sysdeps/linux/metag/bits/kernel_stat.h
new file mode 100644
index 0000000..1479d15
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/kernel_stat.h
@@ -0,0 +1,49 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+#ifndef _LIBC
+#error bits/kernel_stat.h is for internal uClibc use only!
+#endif
+
+/* This file provides whatever this particular arch's kernel thinks 
+ * struct kernel_stat should look like...  It turns out each arch has a 
+ * different opinion on the subject... */
+struct kernel_stat {
+	__kernel_dev_t	st_dev;
+	__kernel_ino_t	st_ino;
+	__kernel_mode_t	st_mode;
+	__kernel_nlink_t st_nlink;
+	__kernel_uid_t	st_uid;
+	__kernel_gid_t 	st_gid;
+	__kernel_dev_t	st_rdev;
+	__kernel_off_t	st_size;
+	unsigned long  	st_blksize;
+	unsigned long  	st_blocks;
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	unsigned long  	__unused4;
+	unsigned long  	__unused5;
+};
+
+struct kernel_stat64 {
+	unsigned long long st_dev; 	/* Device.  */
+	unsigned long long st_ino;	/* File serial number.  */
+	unsigned int st_mode;		/* File mode.  */
+	unsigned int st_nlink;		/* Link count.  */
+	unsigned int st_uid;		/* User ID of the file's owner.  */
+	unsigned int st_gid;		/* Group ID of the file's group. */
+	unsigned long long st_rdev; 	/* Device number, if device.  */
+	unsigned short int __pad2;
+	long long st_size;		/* Size of file, in bytes.  */
+	long st_blksize;		/* Optimal block size for I/O.  */
+	long long st_blocks;		/* Number 512-byte blocks allocated. */
+	struct timespec st_atim;
+	struct timespec st_mtim;
+	struct timespec st_ctim;
+	unsigned long int __unused4;
+	unsigned long int __unused5;
+};
+
+#endif	/*  _BITS_STAT_STRUCT_H */
+
diff --git a/libc/sysdeps/linux/metag/bits/kernel_types.h b/libc/sysdeps/linux/metag/bits/kernel_types.h
new file mode 100644
index 0000000..6e61140
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/kernel_types.h
@@ -0,0 +1,41 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ASM_GENERIC_POSIX_TYPES_H
+#define __ASM_GENERIC_POSIX_TYPES_H
+
+typedef unsigned int	__kernel_dev_t;
+typedef unsigned int	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+typedef unsigned long	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef int             __kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef unsigned int	__kernel_old_uid_t;
+typedef unsigned int	__kernel_old_gid_t;
+typedef __kernel_dev_t	__kernel_old_dev_t;
+typedef long long	__kernel_loff_t;
+
+typedef struct {
+	int val[2];
+} __kernel_fsid_t;
+
+#endif /* __ASM_GENERIC_POSIX_TYPES_H */
+
diff --git a/libc/sysdeps/linux/metag/bits/mman.h b/libc/sysdeps/linux/metag/bits/mman.h
new file mode 100644
index 0000000..0cdeee5
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/mman.h
@@ -0,0 +1,104 @@
+/* Definitions for POSIX memory map interface.  Linux/SH version.
+   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define _MAP_NEW	0x80000000	/* Binary compatibility with SunOS.  */
+# define MAP_POPULATE	0x8000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+# define MAP_UNINITIALIZE 0x4000000     /* For anonymous mmap, memory could
+					   be uninitialized. */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_SPACEAVAIL  5	/* insure that resources are reserved */
+# define MADV_VPS_PURGE	  6	/* Purge pages from VM page cache */
+# define MADV_VPS_INHERIT 7	/* Inherit parents page size */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --git a/libc/sysdeps/linux/metag/bits/profil-counter.h b/libc/sysdeps/linux/metag/bits/profil-counter.h
new file mode 100644
index 0000000..a0c8973
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/profil-counter.h
@@ -0,0 +1,26 @@
+/* Low-level statistical profiling support function.  Linux/SH version.
+   Copyright (C) 1996, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <signal.h>
+
+static void
+profil_counter (int signo, struct sigcontext sc)
+{
+  profil_count (sc.cbuf.ctx.CurrPC);
+}
diff --git a/libc/sysdeps/linux/metag/bits/setjmp.h b/libc/sysdeps/linux/metag/bits/setjmp.h
new file mode 100644
index 0000000..d081686
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/setjmp.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the machine-dependent type `jmp_buf'.  META version.  */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+/*
+   jmp_buf[0] - A0StP
+   jmp_buf[1] - A1GbP
+   jmp_buf[2] - A0FrP
+   jmp_buf[3] - A1LbP
+   jmp_buf[4] - D0FrT
+   jmp_buf[5] - D1RtP
+   jmp_buf[6] - D0.5
+   jmp_buf[7] - D1.5
+   jmp_buf[8] - D0.6
+   jmp_buf[9] - D1.6
+   jmp_buf[10] - D0.7
+   jmp_buf[11] - D1.7
+   */
+
+#define _JBLEN 24
+#if     defined (__USE_MISC) || defined (_ASM)
+#define JB_SP 0
+#endif
+
+#ifndef	_ASM
+typedef int __jmp_buf[_JBLEN] __attribute__((aligned (8)));
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) > (void *) (jmpbuf)[JB_SP])
+
+#endif	/* bits/setjmp.h */
diff --git a/libc/sysdeps/linux/metag/bits/sigcontextinfo.h b/libc/sysdeps/linux/metag/bits/sigcontextinfo.h
new file mode 100644
index 0000000..37fc3c3
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/sigcontextinfo.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Philip Blundell <philb@gnu.org>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIGCONTEXT struct sigcontext
+#define SIGCONTEXT_EXTRA_ARGS
+#define GET_PC(ctx)	((void *) ctx.cbuf.ctx.CurrPC)
+#define GET_FRAME(ctx)	((void *) ctx.cbuf.ctx.AX[1].U0)
+#define GET_STACK(ctx)	((void *) ctx.cbuf.ctx.AX[0].U0)
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/libc/sysdeps/linux/metag/bits/stackinfo.h b/libc/sysdeps/linux/metag/bits/stackinfo.h
new file mode 100644
index 0000000..afe04bb
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On META the stack grows up.  */
+#define _STACK_GROWS_UP	1
+
+#endif	/* stackinfo.h */
diff --git a/libc/sysdeps/linux/metag/bits/syscalls.h b/libc/sysdeps/linux/metag/bits/syscalls.h
new file mode 100644
index 0000000..94c9187
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/syscalls.h
@@ -0,0 +1,123 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+#ifdef __NR_pread64
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#ifdef __NR_pwrite64
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+/*
+  META version adapted from the ARM version.
+*/
+
+#define SYS_ify(syscall_name)  (__NR_##syscall_name)
+
+#ifdef __ASSEMBLER__
+
+/* Call a given syscall, with arguments loaded. */
+#undef DO_CALL
+#define DO_CALL(syscall_name, args)		\
+  MOV D1Re0, #SYS_ify (syscall_name);		\
+  SWITCH #0x440001
+
+#else
+
+#include <errno.h>
+
+#undef INLINE_SYSCALL_NCS
+#define INLINE_SYSCALL_NCS(name, nr, args...)				\
+  ({ unsigned int _inline_sys_result = INTERNAL_SYSCALL_NCS (name, , nr, args); \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_inline_sys_result, ), 0)) \
+      {									\
+	__set_errno (INTERNAL_SYSCALL_ERRNO (_inline_sys_result, ));	\
+	_inline_sys_result = (unsigned int) -1;				\
+      }									\
+    (int) _inline_sys_result; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...)			\
+  ({unsigned int __sys_result;						\
+    {									\
+      PREP_ARGS_##nr (args);						\
+      register int _result __asm__ ("D0Re0"), _nr __asm__ ("D1Re0");	\
+      LOAD_ARGS_##nr;							\
+      _nr = (name);							\
+      __asm__ volatile ("SWITCH  #0x440001 ! syscall " #name		\
+                        : "=r" (_result)				\
+                        : "d" (_nr) ASM_ARGS_##nr			\
+                        : "memory");					\
+      __sys_result = _result;						\
+    }									\
+    (int) __sys_result; })
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned int) (val) >= 0xfffff001u)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
+
+#define PREP_ARGS_0()
+#define PREP_ARGS_1(a1)                                 \
+  int _t1 = (int) (a1);                                 \
+  PREP_ARGS_0 ()
+#define PREP_ARGS_2(a1, a2)                             \
+  int _t2 = (int) (a2);                                 \
+  PREP_ARGS_1 (a1)
+#define PREP_ARGS_3(a1, a2, a3)                         \
+  int _t3 = (int) (a3);                                 \
+  PREP_ARGS_2 (a1, a2)
+#define PREP_ARGS_4(a1, a2, a3, a4)                     \
+  int _t4 = (int) (a4);                                 \
+  PREP_ARGS_3 (a1, a2, a3)
+#define PREP_ARGS_5(a1, a2, a3, a4, a5)                 \
+  int _t5 = (int) (a5);                                 \
+  PREP_ARGS_4 (a1, a2, a3, a4)
+#define PREP_ARGS_6(a1, a2, a3, a4, a5, a6)             \
+  int _t6 = (int) (a6);                                 \
+  PREP_ARGS_5 (a1, a2, a3, a4, a5)
+
+#define LOAD_ARGS_0
+#define ASM_ARGS_0
+#define LOAD_ARGS_1                                     \
+  register int _a1 __asm__ ("D1Ar1") = (int) (_t1);     \
+  LOAD_ARGS_0
+#define ASM_ARGS_1 ASM_ARGS_0, "d" (_a1)
+#define LOAD_ARGS_2                                     \
+  register int _a2 __asm__ ("D0Ar2") = (int) (_t2);     \
+  LOAD_ARGS_1
+#define ASM_ARGS_2 ASM_ARGS_1, "d" (_a2)
+#define LOAD_ARGS_3                                     \
+  register int _a3 __asm__ ("D1Ar3") = (int) (_t3);     \
+  LOAD_ARGS_2
+#define ASM_ARGS_3 ASM_ARGS_2, "d" (_a3)
+#define LOAD_ARGS_4                                     \
+  register int _a4 __asm__ ("D0Ar4") = (int) (_t4);     \
+  LOAD_ARGS_3
+#define ASM_ARGS_4 ASM_ARGS_3, "d" (_a4)
+#define LOAD_ARGS_5                                     \
+  register int _a5 __asm__ ("D1Ar5") = (int) (_t5);     \
+  LOAD_ARGS_4
+#define ASM_ARGS_5 ASM_ARGS_4, "d" (_a5)
+#define LOAD_ARGS_6                                     \
+  register int _a6 __asm__ ("D0Ar6") = (int) (_t6);     \
+  LOAD_ARGS_5
+#define ASM_ARGS_6 ASM_ARGS_5, "d" (_a6)
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
diff --git a/libc/sysdeps/linux/metag/bits/uClibc_arch_features.h b/libc/sysdeps/linux/metag/bits/uClibc_arch_features.h
new file mode 100644
index 0000000..f56ab1c
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/uClibc_arch_features.h
@@ -0,0 +1,42 @@
+/*
+ * Track misc arch-specific features that aren't config options
+ */
+
+#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
+#define _BITS_UCLIBC_ARCH_FEATURES_H
+
+/* instruction used when calling abort() to kill yourself */
+/*#define __UCLIBC_ABORT_INSTRUCTION__ "asm instruction"*/
+#undef __UCLIBC_ABORT_INSTRUCTION__
+
+/* can your target use syscall6() for mmap ? */
+#define __UCLIBC_MMAP_HAS_6_ARGS__
+
+/* does your target use syscall4() for truncate64 ? (32bit arches only) */
+#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
+
+/* does your target have a broken create_module() ? */
+#undef __UCLIBC_BROKEN_CREATE_MODULE__
+
+/* does your target have to worry about older [gs]etrlimit() ? */
+#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
+
+/* does your target have an asm .set ? */
+#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
+
+/* define if target doesn't like .global */
+#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
+
+/* define if target supports .weak */
+#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
+
+/* define if target supports .weakext */
+#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
+
+/* needed probably only for ppc64 */
+#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
+
+/* define if target supports IEEE signed zero floats */
+#define __UCLIBC_HAVE_SIGNED_ZERO__
+
+#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff --git a/libc/sysdeps/linux/metag/bits/wordsize.h b/libc/sysdeps/linux/metag/bits/wordsize.h
new file mode 100644
index 0000000..ba643b6
--- /dev/null
+++ b/libc/sysdeps/linux/metag/bits/wordsize.h
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff --git a/libc/sysdeps/linux/metag/brk.c b/libc/sysdeps/linux/metag/brk.c
new file mode 100644
index 0000000..90cee4d
--- /dev/null
+++ b/libc/sysdeps/linux/metag/brk.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2010 Imagination Technologies Ltd.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+libc_hidden_proto(brk)
+
+/* This must be initialized data because commons can't have aliases.  */
+void * __curbrk attribute_hidden = 0;
+
+int brk (void *addr)
+{
+    void *newbrk;
+
+    __asm__ __volatile__ ("MOV D1Re0,%2\n\t"
+			  "MOV D1Ar1,%1\n\t"
+			  "SWITCH #0x440001\n\t"
+			  "MOV %0,D0Re0"
+			  : "=r" (newbrk)
+			  : "r" (addr), "K" (__NR_brk)
+			  : "D0Re0", "D1Re0", "D1Ar1");
+
+    __curbrk = newbrk;
+
+    if (newbrk < addr)
+    {
+	__set_errno (ENOMEM);
+	return -1;
+    }
+
+    return 0;
+}
+libc_hidden_def(brk)
diff --git a/libc/sysdeps/linux/metag/clone.S b/libc/sysdeps/linux/metag/clone.S
new file mode 100644
index 0000000..0c34c9f
--- /dev/null
+++ b/libc/sysdeps/linux/metag/clone.S
@@ -0,0 +1,99 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <asm/errno.h>
+#include <asm/unistd.h>
+
+#define CLONE_VM      0x00000100
+#define CLONE_THREAD  0x00010000
+
+#ifdef __PIC__
+#define __CLONE_METAG_LOAD_TP ___metag_load_tp@PLT
+#else
+#define __CLONE_METAG_LOAD_TP ___metag_load_tp
+#endif
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+			pid_t *ptid, struct user_desc *tls, pid_t *ctid); */
+
+	.text
+	.global	__clone
+	.type	__clone,function
+__clone:
+	! sanity check args
+	MOV	D0Re0, #-EINVAL
+        CMP	D1Ar1, #0
+        BEQ     ___error
+	CMP	D0Ar2, #0
+        BEQ     ___error
+
+        ! save function pointer
+        MOV D0FrT, D1Ar1
+
+	! do the system call
+        MOV     D1Ar1, D1Ar3
+        MOV     D1Ar3, D1Ar5
+        MOV     D1Ar5, D0Ar6
+        MOV     D0Ar6, D0Ar4
+        GETD    D0Ar4, [A0StP+#-4]
+
+	! new sp is already in D0Ar2
+        MOV     D1Re0, #__NR_clone
+        SWITCH  #0x440001
+	CMP     D0Re0,#0
+        ! Error on -1
+	BLT	___error
+        ! If non-zero we are the parent
+        MOVNE   PC, D1RtP
+        ! BRKPNT
+
+        ! We are the child
+#ifdef RESET_PID
+        SETL    [A0StP++], D0FrT, D1RtP
+        MOVT    D0FrT, #HI(CLONE_THREAD)
+        ADD     D0FrT, D0FrT, #LO(CLONE_THREAD)
+        ANDS    D0FrT, D0FrT, D1Ar1
+        BNZ     3f
+        MOVT    D0FrT, #HI(CLONE_VM)
+        ADD     D0FrT, D0FrT, #LO(CLONE_VM)
+        ANDS    D0FrT, D0FrT, D1Ar1
+        BZ      1f
+        MOV     D1Ar1, #-1
+        BA      2f
+1:      MOV     D1Re0, #__NR_getpid
+        SWITCH  #0x440001
+        MOV     D1Ar1, D0Re0
+2:      CALLR   D1RtP, __CLONE_METAG_LOAD_TP
+        SUB     D0Re0, D0Re0, #TLS_PRE_TCB_SIZE
+        SETD    [D0Re0 + #PID], D1Ar1
+        SETD    [D0Re0 + #TID], D1Ar1
+3:      GETL    D0FrT, D1RtP, [--A0StP]
+#endif
+        ! Rearrange the function arg and call address from registers
+        MOV     D0Ar2, D0FrT
+        MOV     D1Ar1, D0Ar6
+        MOV     D1RtP, PC
+        ADD     D1RtP, D1RtP, #8
+        MOV     PC, D0Ar2
+
+        ! and we are done, passing the return value D0Re0 through D1Ar1
+        MOV     D1Ar1, D0Re0
+#ifdef __PIC__
+        B       _exit@PLT
+#else
+        B       _exit
+#endif
+
+___error:
+        MOV     D1Ar1, D0Re0
+#ifdef __PIC__
+        B       ___syscall_error@PLT
+#else
+        B       ___syscall_error
+#endif
+        .size   __clone, .-__clone
+
+.weak    _clone
+_clone    =   __clone
diff --git a/libc/sysdeps/linux/metag/crt1.S b/libc/sysdeps/linux/metag/crt1.S
new file mode 100644
index 0000000..42ee7e1
--- /dev/null
+++ b/libc/sysdeps/linux/metag/crt1.S
@@ -0,0 +1,72 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+#include <asm/unistd.h>
+
+	.text
+	.global	__start
+	.type	__start,function
+__start:
+       	MOV	D0FrT,A0StP
+	MOV	A0FrP,A0StP
+
+        MOV     A0.2,#0
+        MOV     A0.3,#0
+
+        MOV     A1.1,#0
+        MOV     A1.2,#0
+        MOV     A1.3,#0
+
+	MOV     D0.5,#0
+	MOV     D0.6,#0
+	MOV     D0.7,#0
+
+	MOV     D1.5,#0
+	MOV     D1.6,#0
+	MOV     D1.7,#0
+
+        MOV     D1Ar3,D0Ar2                     ! argv
+        MOV     D0Ar2,D1Ar1                     ! argc
+        MOV     D0Ar6,D0Ar4                     ! rtld_fini
+
+#ifdef __PIC__
+	ADDT    A1LbP,CPC1,#HI(__GLOBAL_OFFSET_TABLE__)
+	ADD     A1LbP,A1LbP,#LO(__GLOBAL_OFFSET_TABLE__+4)
+
+	MOV	D1Ar1,A1LbP
+	ADDT	D1Ar1,D1Ar1,#HI(_main@GOTOFF)
+	ADD	D1Ar1,D1Ar1,#LO(_main@GOTOFF)
+
+	MOV	D0Ar4,A1LbP
+	ADDT	D0Ar4,D0Ar4,#HI(__init@GOTOFF)
+	ADD	D0Ar4,D0Ar4,#LO(__init@GOTOFF)
+
+	MOV	D1Ar5,A1LbP
+	ADDT	D1Ar5,D1Ar5,#HI(__fini@GOTOFF)
+	ADD	D1Ar5,D1Ar5,#LO(__fini@GOTOFF)
+#else
+        MOVT    D1Ar1,#HI(_main)
+        ADD     D1Ar1,D1Ar1,#LO(_main)
+	MOVT    D0Ar4,#HI(__init)
+        ADD     D0Ar4,D0Ar4,#LO(__init)
+	MOVT    D1Ar5,#HI(__fini)
+        ADD     D1Ar5,D1Ar5,#LO(__fini)
+#endif
+
+        MOVT    D1Re0,#0x80
+
+        SETL    [A0StP++],D0Re0,D1Re0           ! stack_end (8Mb)
+
+        MOV     D1Re0,#0
+	MOV     D0Re0,#0
+
+#ifdef __PIC__
+	CALLR   D1RtP, ___uClibc_main@PLT
+#else
+	CALLR   D1RtP, ___uClibc_main
+#endif
+
+        MOV     D1Re0,#__NR_exit
+        MOV     D1Ar1,#0x1
+	SWITCH	#0x440001                    ! exit syscall
+
+        .size __start,.-__start
diff --git a/libc/sysdeps/linux/metag/crti.S b/libc/sysdeps/linux/metag/crti.S
new file mode 100644
index 0000000..0dc924b
--- /dev/null
+++ b/libc/sysdeps/linux/metag/crti.S
@@ -0,0 +1,17 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+	.section .init
+	.global	__init
+	.type	__init,function
+__init:
+        MOV     D0FrT, A0FrP
+        ADD     A0FrP, A0StP, #0
+        SETL    [A0StP++], D0.4, D1RtP
+        	
+	.section .fini
+	.global	__fini
+	.type	__fini,function
+__fini:
+        MOV     D0FrT, A0FrP
+        ADD     A0FrP, A0StP, #0
+        SETL    [A0StP++], D0.4, D1RtP
diff --git a/libc/sysdeps/linux/metag/crtn.S b/libc/sysdeps/linux/metag/crtn.S
new file mode 100644
index 0000000..d21a16c
--- /dev/null
+++ b/libc/sysdeps/linux/metag/crtn.S
@@ -0,0 +1,17 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+	.section .init
+	.global	__init
+	.type	__init,function
+        GETL    D0.4, D1RtP, [A0FrP+#8++]
+        SUB     A0StP, A0FrP, #8
+        MOV     A0FrP, D0.4
+        MOV     PC, D1RtP        
+	
+	.section .fini
+	.global	__fini
+	.type	__fini,function
+        GETL    D0.4, D1RtP, [A0FrP+#8++]
+        SUB     A0StP, A0FrP, #8
+        MOV     A0FrP, D0.4
+        MOV     PC, D1RtP
diff --git a/libc/sysdeps/linux/metag/libc-metag_load_tp.S b/libc/sysdeps/linux/metag/libc-metag_load_tp.S
new file mode 100644
index 0000000..8797b78
--- /dev/null
+++ b/libc/sysdeps/linux/metag/libc-metag_load_tp.S
@@ -0,0 +1 @@
+#include <ldso/ldso/metag/metag_load_tp.S>
diff --git a/libc/sysdeps/linux/metag/metag.c b/libc/sysdeps/linux/metag/metag.c
new file mode 100644
index 0000000..0cf8415
--- /dev/null
+++ b/libc/sysdeps/linux/metag/metag.c
@@ -0,0 +1,8 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+#include <errno.h>
+#include <sys/syscall.h>
+
+_syscall1(int,metag_spinlock,int *,spinlock)
+_syscall2(int,metag_setglobalbit,char *,addr,int,mask)
+_syscall1(void,metag_set_fpu_flags,unsigned int,flags)
diff --git a/libc/sysdeps/linux/metag/setjmp.S b/libc/sysdeps/linux/metag/setjmp.S
new file mode 100644
index 0000000..a4e04c5
--- /dev/null
+++ b/libc/sysdeps/linux/metag/setjmp.S
@@ -0,0 +1,48 @@
+/* Copyright (C) 2010 Imagination Technologies Ltd. */
+
+!!! setjmp and variants
+        .text
+
+!! int _setjmp (jmp_buf __env)
+!! Store the calling environment in ENV, not saving the signal mask.
+!! Return 0.  */
+        .global __setjmp
+        .type   __setjmp,function
+__setjmp:
+        MOV     D0Ar2,#0
+        B       ___sigsetjmp1
+        .size   __setjmp,.-__setjmp
+
+!! int setjmp (jmp_buf __env)
+!! Store the calling environment in ENV, also saving the signal mask.
+!! Return 0.  */
+        .global _setjmp
+        .type   _setjmp,function
+_setjmp:
+        MOV     D0Ar2,#1
+        !! fall through to __sigsetjmp
+        .size   _setjmp,.-_setjmp
+
+!! int __sigsetjmp (jmp_buf __env, int __savemask)
+!! Store the calling environment in ENV, also saving the
+!! signal mask if SAVEMASK is nonzero.  Return 0.
+!! This is the internal name for `sigsetjmp'.
+        .global ___sigsetjmp
+        .type   ___sigsetjmp,function
+___sigsetjmp:
+___sigsetjmp1:
+        !! Save A0/A1 regs
+        MSETL   [D1Ar1++],A0.0,A0.1
+        !! Use A0.3 as temp
+        MOV     A0.3,D1Ar1
+        !! Rewind D1Ar1 that was modified above
+        SUB     D1Ar1,D1Ar1,#(2*8)
+        !! Save D0/D1 regs
+        MSETL   [A0.3++],D0FrT,D0.5,D0.6,D0.7
+        !! Tail call __sigjmp_save
+#ifdef __PIC__
+        B       ___sigjmp_save@PLT
+#else
+        B       ___sigjmp_save
+#endif
+        .size   ___sigsetjmp,.-___sigsetjmp
diff --git a/libc/sysdeps/linux/metag/sys/io.h b/libc/sysdeps/linux/metag/sys/io.h
new file mode 100644
index 0000000..6fdc44f
--- /dev/null
+++ b/libc/sysdeps/linux/metag/sys/io.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 1996, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+
+#define	_SYS_IO_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL is nonzero,
+   permission to access any I/O port is granted.  This call requires
+   root privileges. */
+extern int iopl (int __level) __THROW;
+
+/* The functions that actually perform reads and writes.  */
+extern unsigned char inb (unsigned long int port) __THROW;
+extern unsigned short int inw (unsigned long int port) __THROW;
+extern unsigned long int inl (unsigned long int port) __THROW;
+
+extern void outb (unsigned char value, unsigned long int port) __THROW;
+extern void outw (unsigned short value, unsigned long int port) __THROW;
+extern void outl (unsigned long value, unsigned long int port) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_IO_H */
diff --git a/libc/sysdeps/linux/metag/sys/procfs.h b/libc/sysdeps/linux/metag/sys/procfs.h
new file mode 100644
index 0000000..f6f8752
--- /dev/null
+++ b/libc/sysdeps/linux/metag/sys/procfs.h
@@ -0,0 +1,121 @@
+/* Copyright (C) 1996, 1997, 1999, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG 128
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+#define ELF_NFPREG 18
+typedef unsigned long elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/metag/sys/ucontext.h b/libc/sysdeps/linux/metag/sys/ucontext.h
new file mode 100644
index 0000000..7c5889d
--- /dev/null
+++ b/libc/sysdeps/linux/metag/sys/ucontext.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 1998, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* META ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	18
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15
+#define R15	R15
+};
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/metag/sys/user.h b/libc/sysdeps/linux/metag/sys/user.h
new file mode 100644
index 0000000..6d0f661
--- /dev/null
+++ b/libc/sysdeps/linux/metag/sys/user.h
@@ -0,0 +1,37 @@
+#ifndef _SYS_USER_H
+#define _SYS_USER_H
+
+#include <asm/ptrace.h>
+
+/* asm/ptrace.h pollutes the namespace.  */
+#undef PTRACE_GETREGS
+#undef PTRACE_SETREGS
+#undef PTRACE_GETFPREGS
+#undef PTRACE_SETFPREGS
+
+struct user_fpregs
+{
+
+};
+
+struct user_regs
+{
+	struct pt_regs regs;
+};
+
+struct user
+{
+       struct user_regs        regs;           /* general registers */
+       size_t                  u_tsize;        /* text size (pages) */
+       size_t                  u_dsize;        /* data size (pages) */
+       size_t                  u_ssize;        /* stack size (pages) */
+       unsigned long           start_code;     /* text starting address */
+       unsigned long           start_data;     /* data starting address */
+       unsigned long           start_stack;    /* stack starting address */
+       long int                signal;         /* signal causing core dump */
+       struct user_regs *      u_ar0;          /* help gdb find registers */
+       unsigned long           magic;          /* identifies a core file */
+       char                    u_comm[32];     /* user command name */
+};
+
+#endif /* _SYS_USER_H */
diff --git a/libc/sysdeps/linux/metag/syscall.c b/libc/sysdeps/linux/metag/syscall.c
new file mode 100644
index 0000000..d94e749
--- /dev/null
+++ b/libc/sysdeps/linux/metag/syscall.c
@@ -0,0 +1,44 @@
+/* syscall for META/uClibc
+ *
+ * Copyright (C) 2007 Imagination Technologies Ltd.
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <features.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+#if __NR_exit == 1
+#error Legacy system call interface not supported, use newer kernel headers
+#endif
+
+long syscall(long sysnum,
+	     long arg1, long arg2, long arg3,
+	     long arg4, long arg5, long arg6)
+{
+
+	register long __call __asm__ ("D1Re0") = sysnum;
+	register long __res __asm__ ("D0Re0");
+	register long __a __asm__ ("D1Ar1") = arg1;
+	register long __b __asm__ ("D0Ar2") = arg2;
+	register long __c __asm__ ("D1Ar3") = arg3;
+	register long __d __asm__ ("D0Ar4") = arg4;
+	register long __e __asm__ ("D1Ar5") = arg5;
+	register long __f __asm__ ("D0Ar6") = arg6;
+
+
+	__asm__ __volatile__ ("SWITCH  #0x440001"
+			      : "=d" (__res)
+			      : "d" (__call), "d" (__a), "d" (__b),
+				"d" (__c), "d" (__d), "d" (__e) , "d" (__f)
+			      : "memory");
+
+	if(__res >= (unsigned long) -4095) {
+		long err = __res;
+		(*__errno_location()) = (-err);
+		__res = (unsigned long) -1;
+	}
+	return (long) __res;
+}
diff --git a/libc/sysdeps/linux/metag/sysdep.h b/libc/sysdeps/linux/metag/sysdep.h
new file mode 100644
index 0000000..f260a60
--- /dev/null
+++ b/libc/sysdeps/linux/metag/sysdep.h
@@ -0,0 +1,71 @@
+/* Assembler macros for META.
+   Copyright (C) 2010-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <common/sysdep.h>
+
+#include <features.h>
+#include <libc-internal.h>
+
+#ifdef	__ASSEMBLER__
+
+#ifdef SHARED
+#define PLTJMP(_x)	_x##@PLT
+#else
+#define PLTJMP(_x)	_x
+#endif
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						\
+  SYSCALL_ERROR_HANDLER							\
+  END (name)
+
+#if defined NOT_IN_libc
+# define SYSCALL_ERROR __local_syscall_error
+# ifdef RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER					\
+__local_syscall_error:						\
+       NEG	D0Re0, D0Re0;					\
+       ADDT	D1Re0, CPC1, #HI(_rtld_errno);			\
+       ADD	D1Re0, D1Re0, #LO(_rtld_errno) + 4;		\
+       SETD	[D1Re0], D0Re0;					\
+       NEG	D0Re0, #0x1;					\
+       MOV	PC, D1RtP;
+# else
+#  define SYSCALL_ERROR_HANDLER					\
+__local_syscall_error:						\
+	MOV	D1Re0, D1RtP;					\
+	SETL	[A0StP++], D0Re0, D1Re0;			\
+	CALLR	D1RtP, PLTJMP(___errno_location);		\
+	GETD	D1Re0, [A0StP+#-8];				\
+	NEG	D1Re0, D1Re0;					\
+	SETD	[D0Re0], D1Re0;					\
+	NEG	D0Re0, #0x1;					\
+	GETD	D1RtP, [A0StP+#-4];				\
+	SUB	A0StP, A0StP, #0x8;				\
+	MOV	PC, D1RtP;
+# endif
+#else
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+# define SYSCALL_ERROR ___syscall_error
+#endif
+
+#endif /* __ASSEMBLER __*/
+
+/* Pointer mangling is not yet supported for META.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
diff --git a/libc/sysdeps/linux/metag/vfork.S b/libc/sysdeps/linux/metag/vfork.S
new file mode 100644
index 0000000..60354f1
--- /dev/null
+++ b/libc/sysdeps/linux/metag/vfork.S
@@ -0,0 +1,81 @@
+/* Copyright (C) 2011-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tcb-offsets.h>
+#include <asm/unistd.h>
+
+#define _ERRNO_H
+#include <bits/errno.h>
+#include <sys/syscall.h>
+
+#ifndef SAVE_PID
+#define SAVE_PID
+#endif
+
+#ifndef RESTORE_PID
+#define RESTORE_PID
+#endif
+
+#ifdef __NR_vfork
+#define __VFORK_NR __NR_vfork
+#else
+#define __VFORK_NR __NR_fork
+#endif
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+	.balign 4
+	.global	___vfork
+	.hidden	___vfork
+	.type	___vfork, @function
+___vfork:
+
+	SAVE_PID
+
+	MOV	D1Ar1, #0x4111	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
+	MOV	D0Ar2, #0
+	MOV	D1Ar3, #0
+	MOV	D0Ar4, #0
+	MOV	D1Ar5, #0
+	MOV	D0Ar6, #0
+	MOV	D1Re0, #__NR_clone
+	SWITCH  #0x440001
+
+	RESTORE_PID
+
+	MOVT	D1Re0, #HI(-4096)
+	ADD	D1Re0, D1Re0, #LO(-4096)
+	CMP	D1Re0, D0Re0
+	BCS	error
+
+	/* Syscall worked. Return to child/parent */
+	MOV	PC, D1RtP
+
+error:
+	MOV	D1Ar1, D0Re0
+#ifdef __PIC__
+	B	___syscall_error@PLT
+#else
+	B	___syscall_error
+#endif
+	.size ___vfork,.-___vfork
+
+weak_alias(__vfork,vfork)
+libc_hidden_weak(vfork)
diff --git a/libm/metag/Makefile.arch b/libm/metag/Makefile.arch
new file mode 100644
index 0000000..c10e5f9
--- /dev/null
+++ b/libm/metag/Makefile.arch
@@ -0,0 +1,24 @@
+# Makefile for uClibc
+#
+# Copyright (c) 2007  STMicroelectronics Ltd
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+ifeq ($(UCLIBC_HAS_FENV),y)
+ifeq ($(CONFIG_META_2_1),y)
+libm_ARCH_SRC:=$(wildcard $(libm_ARCH_DIR)/*.c)
+libm_ARCH_OBJ:=$(patsubst $(libm_ARCH_DIR)/%.c,$(libm_ARCH_OUT)/%.o,$(libm_ARCH_SRC))
+CFLAGS-libm += -Wa,-mfpu=metac21
+endif
+endif
+
+libm_ARCH_OBJS:=$(libm_ARCH_OBJ)
+
+ifeq ($(DOPIC),y)
+libm-a-y+=$(libm_ARCH_OBJS:.o=.os)
+else
+libm-a-y+=$(libm_ARCH_OBJS)
+endif
+libm-so-y+=$(libm_ARCH_OBJS:.o=.os)
+
diff --git a/libm/metag/fclrexcpt.c b/libm/metag/fclrexcpt.c
new file mode 100644
index 0000000..8cb3e15
--- /dev/null
+++ b/libm/metag/fclrexcpt.c
@@ -0,0 +1,44 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+#include "internal.h"
+
+int
+feclearexcept (int excepts)
+{
+  unsigned int temp;
+
+  /* Get the current exceptions.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (temp));
+
+  /* Mask out unsupported bits/exceptions.  */
+  excepts &= FE_ALL_EXCEPT;
+
+  excepts <<= 16;
+
+  temp &= ~excepts;
+
+  metag_set_fpu_flags(temp);
+
+  /* Success.  */
+  return 0;
+}
diff --git a/libm/metag/fedisblxcpt.c b/libm/metag/fedisblxcpt.c
new file mode 100644
index 0000000..d04ecc2
--- /dev/null
+++ b/libm/metag/fedisblxcpt.c
@@ -0,0 +1,40 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+#include "internal.h"
+
+int
+fedisableexcept (int excepts)
+{
+  unsigned int old_exc;
+
+  /* Get the current control word.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (old_exc));
+
+  old_exc &= FE_ALL_EXCEPT;
+
+  excepts = old_exc & ~excepts;
+
+  metag_set_fpu_flags(excepts);
+
+  return old_exc;
+}
diff --git a/libm/metag/feenablxcpt.c b/libm/metag/feenablxcpt.c
new file mode 100644
index 0000000..1f84ac1
--- /dev/null
+++ b/libm/metag/feenablxcpt.c
@@ -0,0 +1,40 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+#include "internal.h"
+
+int
+feenableexcept (int excepts)
+{
+  unsigned int old_exc;
+
+  /* Get the current control word.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (old_exc));
+
+  old_exc &= FE_ALL_EXCEPT;
+
+  excepts |= old_exc;
+
+  metag_set_fpu_flags(excepts);
+
+  return old_exc;
+}
diff --git a/libm/metag/fegetenv.c b/libm/metag/fegetenv.c
new file mode 100644
index 0000000..01b754a
--- /dev/null
+++ b/libm/metag/fegetenv.c
@@ -0,0 +1,36 @@
+/* Store current floating-point environment.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+
+int
+fegetenv (fenv_t *envp)
+{
+  unsigned int txdefr;
+  unsigned int txmode;
+
+  __asm__ ("MOV %0,TXDEFR" : "=r" (txdefr));
+  __asm__ ("MOV %0,TXMODE" : "=r" (txmode));
+
+  envp->txdefr = txdefr;
+  envp->txmode = txmode;
+
+  /* Success.  */
+  return 0;
+}
diff --git a/libm/metag/fegetexcept.c b/libm/metag/fegetexcept.c
new file mode 100644
index 0000000..29b845d
--- /dev/null
+++ b/libm/metag/fegetexcept.c
@@ -0,0 +1,31 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+
+int
+fegetexcept (void)
+{
+  unsigned int exc;
+
+  /* Get the current control word.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (exc));
+
+  return exc & FE_ALL_EXCEPT;
+}
diff --git a/libm/metag/fegetround.c b/libm/metag/fegetround.c
new file mode 100644
index 0000000..c9f47bb
--- /dev/null
+++ b/libm/metag/fegetround.c
@@ -0,0 +1,30 @@
+/* Return current rounding direction.
+   Copyright (C) Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+
+int
+fegetround (void)
+{
+  unsigned int txmode;
+
+  __asm__ ("MOV %0,TXMODE" : "=r" (txmode));
+
+  return (txmode >> 16) & 0x3;
+}
diff --git a/libm/metag/feholdexcpt.c b/libm/metag/feholdexcpt.c
new file mode 100644
index 0000000..41a09be
--- /dev/null
+++ b/libm/metag/feholdexcpt.c
@@ -0,0 +1,41 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) Imagination Technologies Ltd.
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+#include "internal.h"
+
+int
+feholdexcept (fenv_t *envp)
+{
+  unsigned int txdefr;
+  unsigned int txmode;
+
+  __asm__ ("MOV %0,TXDEFR" : "=r" (txdefr));
+  __asm__ ("MOV %0,TXMODE" : "=r" (txmode));
+
+  envp->txdefr = txdefr;
+  envp->txmode = txmode;
+
+  metag_set_fpu_flags(0);
+
+  return 0;
+}
diff --git a/libm/metag/fesetenv.c b/libm/metag/fesetenv.c
new file mode 100644
index 0000000..022eff4
--- /dev/null
+++ b/libm/metag/fesetenv.c
@@ -0,0 +1,60 @@
+/* Install given floating-point environment.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <assert.h>
+
+#include "internal.h"
+
+libm_hidden_proto(fesetenv)
+
+int
+fesetenv (const fenv_t *envp)
+{
+  unsigned int exc;
+  unsigned int txmode;
+
+  __asm__ ("MOV %0,TXMODE" : "=r" (txmode));
+
+  /* Clear rounding mode bits (round to nearest).  */
+  txmode &= ~(0x3 << 16);
+
+  if (envp == FE_DFL_ENV)
+    {
+      exc = 0;
+    }
+  else if (envp == FE_NOMASK_ENV)
+    {
+      exc = 0x1f;
+    }
+  else
+    {
+      exc = envp->txdefr & (FE_ALL_EXCEPT | (FE_ALL_EXCEPT << 16));
+      /* Write rounding mode and guard bit.  */
+      txmode |= (0x1 << 18 ) | (envp->txmode & (0x3 << 16));
+    }
+
+  __asm__ ("MOV TXMODE,%0" : : "r" (txmode));
+
+  metag_set_fpu_flags(exc);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def(fesetenv)
diff --git a/libm/metag/fesetround.c b/libm/metag/fesetround.c
new file mode 100644
index 0000000..8784457
--- /dev/null
+++ b/libm/metag/fesetround.c
@@ -0,0 +1,41 @@
+/* Set current rounding direction.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+int
+fesetround (int round)
+{
+  unsigned int txmode;
+
+  if ((round & ~0x3) != 0)
+    /* ROUND is no valid rounding mode.  */
+    return 1;
+
+  __asm__ ("MOV %0,TXMODE" : "=r" (txmode));
+
+  txmode &= ~(0x3 << 16);
+  /* Write rounding mode and guard bit.  */
+  txmode |= (0x1 << 18 ) | (round << 16);
+
+  __asm__ ("MOV TXMODE,%0" : : "r" (txmode));
+
+  return 0;
+}
diff --git a/libm/metag/feupdateenv.c b/libm/metag/feupdateenv.c
new file mode 100644
index 0000000..c82386e
--- /dev/null
+++ b/libm/metag/feupdateenv.c
@@ -0,0 +1,45 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+libm_hidden_proto(fesetenv)
+libm_hidden_proto(feraiseexcept)
+
+int
+feupdateenv (const fenv_t *envp)
+{
+  unsigned int temp;
+
+  /* Save current exceptions.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (temp));
+
+  temp >>= 16;
+  temp &= FE_ALL_EXCEPT;
+
+  /* Install new environment.  */
+  fesetenv (envp);
+
+  /* Raise the saved exception.  */
+  feraiseexcept ((int) temp);
+
+  /* Success.  */
+  return 0;
+}
diff --git a/libm/metag/fgetexcptflg.c b/libm/metag/fgetexcptflg.c
new file mode 100644
index 0000000..8da20b9
--- /dev/null
+++ b/libm/metag/fgetexcptflg.c
@@ -0,0 +1,34 @@
+/* Store current representation for exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  unsigned int temp;
+
+  /* Get the current exceptions.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (temp));
+
+  *flagp = temp & excepts & FE_ALL_EXCEPT;
+
+  /* Success.  */
+  return 0;
+}
diff --git a/libm/metag/fraiseexcpt.c b/libm/metag/fraiseexcpt.c
new file mode 100644
index 0000000..f4973d2
--- /dev/null
+++ b/libm/metag/fraiseexcpt.c
@@ -0,0 +1,92 @@
+/* Raise given exceptions.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math.h>
+
+libm_hidden_proto(feraiseexcept)
+
+int
+feraiseexcept (int excepts)
+{
+  /* Raise exceptions represented by EXPECTS.  But we must raise only
+     one signal at a time.  It is important that if the overflow/underflow
+     exception and the inexact exception are given at the same time,
+     the overflow/underflow exception follows the inexact exception.  */
+
+  /* First: invalid exception.  */
+  if ((FE_INVALID & excepts) != 0)
+    {
+      /* Reciprocal square root of a negative number is invalid. */
+      __asm__ volatile(
+		   "F MOV FX.0,#0xc000 ! -2\n"
+		   "F RSQ FX.1,FX.0\n"
+		   );
+    }
+
+  /* Next: division by zero.  */
+  if ((FE_DIVBYZERO & excepts) != 0)
+    {
+      __asm__ volatile(
+		   "F MOV FX.0,#0\n"
+		   "F RCP FX.1,FX.0\n"
+		   );
+    }
+
+  /* Next: overflow.  */
+  if ((FE_OVERFLOW & excepts) != 0)
+    {
+      /* Adding a large number in single precision can cause overflow. */
+      __asm__ volatile(
+		   "  MOVT D0.0,#0x7f7f\n"
+		   "  ADD  D0.0,D0.0,#0xffff\n"
+		   "F MOV  FX.0,D0.0\n"
+		   "F ADD  FX.1,FX.0,FX.0\n"
+		   );
+    }
+
+  /* Next: underflow.  */
+  if ((FE_UNDERFLOW & excepts) != 0)
+    {
+      /* Multiplying a small value by 0.5 will cause an underflow. */
+      __asm__ volatile(
+		   "  MOV  D0.0,#1\n"
+		   "F MOV  FX.0,D0.0\n"
+		   "  MOVT D0.0,#0x3f00\n"
+		   "F MOV  FX.1,D0.0\n"
+		   "F MUL  FX.2,FX.1,FX.0\n"
+		   );
+    }
+
+  /* Last: inexact.  */
+  if ((FE_INEXACT & excepts) != 0)
+    {
+      /* Converting a small single precision value to half precision
+	 can cause an inexact exception. */
+      __asm__ volatile(
+		   "  MOV  D0.0,#0x0001\n"
+		   "F MOV  FX.0,D0.0\n"
+		   "F FTOH FX.1,FX.0\n"
+		   );
+    }
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def(feraiseexcept)
diff --git a/libm/metag/fsetexcptflg.c b/libm/metag/fsetexcptflg.c
new file mode 100644
index 0000000..dbe5b32
--- /dev/null
+++ b/libm/metag/fsetexcptflg.c
@@ -0,0 +1,44 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 2009 Imaginatin Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math.h>
+#include <unistd.h>
+
+#include "internal.h"
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  unsigned int temp;
+
+  /* Get the current exceptions.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (temp));
+
+  excepts &= FE_ALL_EXCEPT;
+  excepts <<= 16;
+
+  temp &= ~excepts;
+  temp |= *flagp & excepts;
+
+  metag_set_fpu_flags(temp);
+
+  /* Success.  */
+  return 0;
+}
diff --git a/libm/metag/ftestexcept.c b/libm/metag/ftestexcept.c
new file mode 100644
index 0000000..2c9f607
--- /dev/null
+++ b/libm/metag/ftestexcept.c
@@ -0,0 +1,32 @@
+/* Test exception in current environment.
+   Copyright (C) 2009 Imagination Technologies Ltd.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <unistd.h>
+
+int
+fetestexcept (int excepts)
+{
+  unsigned int temp;
+
+  /* Get the current exceptions.  */
+  __asm__ ("MOV %0,TXDEFR" : "=r" (temp));
+
+  return (temp >> 16) & excepts & FE_ALL_EXCEPT;
+}
diff --git a/libm/metag/internal.h b/libm/metag/internal.h
new file mode 100644
index 0000000..ebc6d82
--- /dev/null
+++ b/libm/metag/internal.h
@@ -0,0 +1,2 @@
+
+void metag_set_fpu_flags(unsigned int flags);
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h b/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
index 80d33be..4931a5d 100644
--- a/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
+++ b/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
@@ -22,10 +22,19 @@
 #include <sysdep.h>
 
 /* Uncancelable open.  */
+#if defined(__NR_openat) && ! defined(__NR_open)
+#define open_not_cancel(name, flags, mode) \
+	INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), \
+		(flags), (mode))
+#define open_not_cancel_2(name, flags) \
+	INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), \
+		(flags))
+#else
 #define open_not_cancel(name, flags, mode) \
    INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
 #define open_not_cancel_2(name, flags) \
    INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+#endif
 
 /* Uncancelable openat.  */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
diff --git a/libpthread/linuxthreads.old/wrapsyscall.c b/libpthread/linuxthreads.old/wrapsyscall.c
index 7424f2e..4288659 100644
--- a/libpthread/linuxthreads.old/wrapsyscall.c
+++ b/libpthread/linuxthreads.old/wrapsyscall.c
@@ -115,9 +115,10 @@ libpthread_hidden_def(nanosleep)
 
 
 /* open(2).  */
+#if ! defined(__NR_openat) && defined(__NR_open)
 CANCELABLE_SYSCALL_VA (int, open, (const char *pathname, int flags, ...),
 		       (pathname, flags, va_arg (ap, mode_t)), flags)
-
+#endif
 
 #ifdef __UCLIBC_HAS_LFS__
 /* open64(3).  */
diff --git a/libpthread/linuxthreads/Makefile.in b/libpthread/linuxthreads/Makefile.in
index 697371b..86959d6 100644
--- a/libpthread/linuxthreads/Makefile.in
+++ b/libpthread/linuxthreads/Makefile.in
@@ -10,6 +10,12 @@ subdirs += libpthread/linuxthreads/sysdeps/$(TARGET_ARCH)
 subdirs += libpthread/linuxthreads/sysdeps/unix/sysv/linux
 subdirs += libpthread/linuxthreads/sysdeps/pthread
 
+CFLAGS-mutex.c += -D__NO_WEAK_PTHREAD_ALIASES
+CFLAGS-specific.c += -D__NO_WEAK_PTHREAD_ALIASES
+CFLAGS-pthread.c += -D__NO_WEAK_PTHREAD_ALIASES
+CFLAGS-ptfork.c += -D__NO_WEAK_PTHREAD_ALIASES
+CFLAGS-cancel.c += -D__NO_WEAK_PTHREAD_ALIASES
+
 CFLAGS-dir_linuxthreads := -DNOT_IN_libc -DIS_IN_libpthread
 CFLAGS-linuxthreads := $(CFLAGS-dir_linuxthreads) $(SSP_ALL_CFLAGS)
 
@@ -69,7 +75,7 @@ CFLAGS-OMIT-libc_pthread_init.c := $(CFLAGS-dir_linuxthreads)
 libpthread_libc_CSRC := \
 	forward.c libc-cancellation.c libc_pthread_init.c # alloca_cutoff.c
 libpthread_libc_OBJ  := $(patsubst %.c, $(libpthread_OUT)/%.o,$(libpthread_libc_CSRC))
-libc-static-y += $(libpthread_OUT)/libc_pthread_init.o
+libc-static-y += $(libpthread_OUT)/libc_pthread_init.o $(libpthread_OUT)/libc-cancellation.o
 libc-shared-y += $(libpthread_libc_OBJ:.o=.oS)
 
 libpthread-static-y += $(patsubst %,$(libpthread_OUT)/%.o,$(libpthread_static_SRC))
diff --git a/libpthread/linuxthreads/attr.c b/libpthread/linuxthreads/attr.c
index 52e115c..1a93bcb 100644
--- a/libpthread/linuxthreads/attr.c
+++ b/libpthread/linuxthreads/attr.c
@@ -26,6 +26,18 @@
 #include "pthread.h"
 #include "internals.h"
 
+libpthread_hidden_proto(__pthread_attr_destroy)
+libpthread_hidden_proto(__pthread_attr_init)
+libpthread_hidden_proto(__pthread_attr_getdetachstate)
+libpthread_hidden_proto(__pthread_attr_setdetachstate)
+libpthread_hidden_proto(__pthread_attr_getinheritsched)
+libpthread_hidden_proto(__pthread_attr_setinheritsched)
+libpthread_hidden_proto(__pthread_attr_getschedparam)
+libpthread_hidden_proto(__pthread_attr_setschedparam)
+libpthread_hidden_proto(__pthread_attr_getschedpolicy)
+libpthread_hidden_proto(__pthread_attr_setschedpolicy)
+libpthread_hidden_proto(__pthread_attr_getscope)
+libpthread_hidden_proto(__pthread_attr_setscope)
 
 int __pthread_attr_init(pthread_attr_t *attr)
 {
@@ -46,12 +58,14 @@ int __pthread_attr_init(pthread_attr_t *attr)
   attr->__stacksize = STACK_SIZE - ps;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_init)
 strong_alias (__pthread_attr_init, pthread_attr_init)
 
 int __pthread_attr_destroy(pthread_attr_t *attr)
 {
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_destroy)
 strong_alias (__pthread_attr_destroy, pthread_attr_destroy)
 
 int __pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
@@ -62,6 +76,7 @@ int __pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
   attr->__detachstate = detachstate;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_setdetachstate)
 strong_alias (__pthread_attr_setdetachstate, pthread_attr_setdetachstate)
 
 int __pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
@@ -69,6 +84,7 @@ int __pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
   *detachstate = attr->__detachstate;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_getdetachstate)
 strong_alias (__pthread_attr_getdetachstate, pthread_attr_getdetachstate)
 
 int __pthread_attr_setschedparam(pthread_attr_t *attr,
@@ -82,6 +98,7 @@ int __pthread_attr_setschedparam(pthread_attr_t *attr,
   memcpy (&attr->__schedparam, param, sizeof (struct sched_param));
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_setschedparam)
 strong_alias (__pthread_attr_setschedparam, pthread_attr_setschedparam)
 
 int __pthread_attr_getschedparam(const pthread_attr_t *attr,
@@ -90,6 +107,7 @@ int __pthread_attr_getschedparam(const pthread_attr_t *attr,
   memcpy (param, &attr->__schedparam, sizeof (struct sched_param));
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_getschedparam)
 strong_alias (__pthread_attr_getschedparam, pthread_attr_getschedparam)
 
 int __pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
@@ -99,6 +117,7 @@ int __pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
   attr->__schedpolicy = policy;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_setschedpolicy)
 strong_alias (__pthread_attr_setschedpolicy, pthread_attr_setschedpolicy)
 
 int __pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
@@ -106,6 +125,7 @@ int __pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
   *policy = attr->__schedpolicy;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_getschedpolicy)
 strong_alias (__pthread_attr_getschedpolicy, pthread_attr_getschedpolicy)
 
 int __pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
@@ -115,6 +135,7 @@ int __pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
   attr->__inheritsched = inherit;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_setinheritsched)
 strong_alias (__pthread_attr_setinheritsched, pthread_attr_setinheritsched)
 
 int __pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
@@ -122,6 +143,7 @@ int __pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
   *inherit = attr->__inheritsched;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_getinheritsched)
 strong_alias (__pthread_attr_getinheritsched, pthread_attr_getinheritsched)
 
 int __pthread_attr_setscope(pthread_attr_t *attr, int scope)
@@ -136,6 +158,7 @@ int __pthread_attr_setscope(pthread_attr_t *attr, int scope)
     return EINVAL;
   }
 }
+libpthread_hidden_def(__pthread_attr_setscope)
 strong_alias (__pthread_attr_setscope, pthread_attr_setscope)
 
 int __pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
@@ -143,6 +166,7 @@ int __pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
   *scope = attr->__scope;
   return 0;
 }
+libpthread_hidden_def(__pthread_attr_getscope)
 strong_alias (__pthread_attr_getscope, pthread_attr_getscope)
 
 int __pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize)
diff --git a/libpthread/linuxthreads/cancel.c b/libpthread/linuxthreads/cancel.c
index 43f0445..681c9f3 100644
--- a/libpthread/linuxthreads/cancel.c
+++ b/libpthread/linuxthreads/cancel.c
@@ -29,6 +29,13 @@
 # error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
 #endif
 
+libpthread_hidden_proto(__pthread_setcancelstate)
+libpthread_hidden_proto(__pthread_setcanceltype)
+
+libpthread_hidden_proto(_pthread_cleanup_push)
+libpthread_hidden_proto(_pthread_cleanup_push_defer)
+libpthread_hidden_proto(_pthread_cleanup_pop)
+libpthread_hidden_proto(_pthread_cleanup_pop_restore)
 
 int __pthread_setcancelstate(int state, int * oldstate)
 {
@@ -43,6 +50,7 @@ int __pthread_setcancelstate(int state, int * oldstate)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   return 0;
 }
+libpthread_hidden_def(__pthread_setcancelstate)
 strong_alias (__pthread_setcancelstate, pthread_setcancelstate)
 
 int __pthread_setcanceltype(int type, int * oldtype)
@@ -58,6 +66,7 @@ int __pthread_setcanceltype(int type, int * oldtype)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   return 0;
 }
+libpthread_hidden_def(__pthread_setcanceltype)
 strong_alias (__pthread_setcanceltype, pthread_setcanceltype)
 
 
@@ -163,6 +172,7 @@ void _pthread_cleanup_push(struct _pthread_cleanup_buffer * buffer,
     buffer->__prev = NULL;
   THREAD_SETMEM(self, p_cleanup, buffer);
 }
+libpthread_hidden_def(_pthread_cleanup_push)
 
 void _pthread_cleanup_pop(struct _pthread_cleanup_buffer * buffer,
 			  int execute)
@@ -171,6 +181,7 @@ void _pthread_cleanup_pop(struct _pthread_cleanup_buffer * buffer,
   if (execute) buffer->__routine(buffer->__arg);
   THREAD_SETMEM(self, p_cleanup, buffer->__prev);
 }
+libpthread_hidden_def(_pthread_cleanup_pop)
 
 void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
 				 void (*routine)(void *), void * arg)
@@ -185,6 +196,7 @@ void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
   THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
   THREAD_SETMEM(self, p_cleanup, buffer);
 }
+libpthread_hidden_def(_pthread_cleanup_push_defer)
 
 void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
 				  int execute)
@@ -198,6 +210,7 @@ void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
       THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
 }
+libpthread_hidden_def(_pthread_cleanup_pop_restore)
 
 extern void __rpc_thread_destroy(void);
 void __pthread_perform_cleanup(char *currentframe)
diff --git a/libpthread/linuxthreads/condvar.c b/libpthread/linuxthreads/condvar.c
index d7b2e98..1483a72 100644
--- a/libpthread/linuxthreads/condvar.c
+++ b/libpthread/linuxthreads/condvar.c
@@ -25,6 +25,15 @@
 #include "queue.h"
 #include "restart.h"
 
+libpthread_hidden_proto(__pthread_condattr_destroy)
+libpthread_hidden_proto(__pthread_condattr_init)
+libpthread_hidden_proto(__pthread_cond_broadcast)
+libpthread_hidden_proto(__pthread_cond_destroy)
+libpthread_hidden_proto(__pthread_cond_init)
+libpthread_hidden_proto(__pthread_cond_signal)
+libpthread_hidden_proto(__pthread_cond_wait)
+libpthread_hidden_proto(__pthread_cond_timedwait)
+
 int __pthread_cond_init(pthread_cond_t *cond,
                         const pthread_condattr_t *cond_attr)
 {
@@ -32,6 +41,7 @@ int __pthread_cond_init(pthread_cond_t *cond,
   cond->__c_waiting = NULL;
   return 0;
 }
+libpthread_hidden_def(__pthread_cond_init)
 strong_alias (__pthread_cond_init, pthread_cond_init)
 
 int __pthread_cond_destroy(pthread_cond_t *cond)
@@ -39,6 +49,7 @@ int __pthread_cond_destroy(pthread_cond_t *cond)
   if (cond->__c_waiting != NULL) return EBUSY;
   return 0;
 }
+libpthread_hidden_def(__pthread_cond_destroy)
 strong_alias (__pthread_cond_destroy, pthread_cond_destroy)
 
 /* Function called by pthread_cancel to remove the thread from
@@ -134,6 +145,7 @@ int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
   pthread_mutex_lock(mutex);
   return 0;
 }
+libpthread_hidden_def(__pthread_cond_wait)
 strong_alias (__pthread_cond_wait, pthread_cond_wait)
 
 static int
@@ -236,6 +248,7 @@ int __pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
   /* Indirect call through pointer! */
   return pthread_cond_timedwait_relative(cond, mutex, abstime);
 }
+libpthread_hidden_def(__pthread_cond_timedwait)
 strong_alias (__pthread_cond_timedwait, pthread_cond_timedwait)
 
 int __pthread_cond_signal(pthread_cond_t *cond)
@@ -252,6 +265,7 @@ int __pthread_cond_signal(pthread_cond_t *cond)
   }
   return 0;
 }
+libpthread_hidden_def(__pthread_cond_signal)
 strong_alias (__pthread_cond_signal, pthread_cond_signal)
 
 int __pthread_cond_broadcast(pthread_cond_t *cond)
@@ -271,18 +285,21 @@ int __pthread_cond_broadcast(pthread_cond_t *cond)
   }
   return 0;
 }
+libpthread_hidden_def(__pthread_cond_broadcast)
 strong_alias (__pthread_cond_broadcast, pthread_cond_broadcast)
 
 int __pthread_condattr_init(pthread_condattr_t *attr)
 {
   return 0;
 }
+libpthread_hidden_def(__pthread_condattr_init)
 strong_alias (__pthread_condattr_init, pthread_condattr_init)
 
 int __pthread_condattr_destroy(pthread_condattr_t *attr)
 {
   return 0;
 }
+libpthread_hidden_def(__pthread_condattr_destroy)
 strong_alias (__pthread_condattr_destroy, pthread_condattr_destroy)
 
 int pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
diff --git a/libpthread/linuxthreads/descr.h b/libpthread/linuxthreads/descr.h
index 47a9acd..e606c3d 100644
--- a/libpthread/linuxthreads/descr.h
+++ b/libpthread/linuxthreads/descr.h
@@ -249,6 +249,7 @@ static __inline__ pthread_descr thread_self (void)
   return THREAD_SELF;
 #else
   char *sp = CURRENT_STACK_FRAME;
+#ifdef _STACK_GROWS_DOWN
   if (sp >= __pthread_initial_thread_bos)
     return &__pthread_initial_thread;
   else if (sp >= __pthread_manager_thread_bos
@@ -257,9 +258,18 @@ static __inline__ pthread_descr thread_self (void)
   else if (__pthread_nonstandard_stacks)
     return __pthread_find_self();
   else
-#ifdef _STACK_GROWS_DOWN
     return (pthread_descr)(((unsigned long)sp | (STACK_SIZE-1))+1) - 1;
 #else
+  if ((sp >= __pthread_initial_thread_bos
+       && sp < (__pthread_initial_thread_bos + STACK_SIZE)) ||
+      (__pthread_initial_thread_bos == 0))
+    return &__pthread_initial_thread;
+  else if (sp >= __pthread_manager_thread_bos
+	   && sp < __pthread_manager_thread_tos)
+    return &__pthread_manager_thread;
+  else if (__pthread_nonstandard_stacks)
+    return __pthread_find_self();
+  else
     return (pthread_descr)((unsigned long)sp &~ (STACK_SIZE-1));
 #endif
 #endif
diff --git a/libpthread/linuxthreads/join.c b/libpthread/linuxthreads/join.c
index 57ea54e..34e9c50 100644
--- a/libpthread/linuxthreads/join.c
+++ b/libpthread/linuxthreads/join.c
@@ -24,10 +24,14 @@
 #include "restart.h"
 #include <not-cancel.h>
 
+libpthread_hidden_proto(__pthread_exit)
+libpthread_hidden_proto(__pthread_do_exit)
+
 void __pthread_exit(void * retval)
 {
   __pthread_do_exit (retval, CURRENT_STACK_FRAME);
 }
+libpthread_hidden_def(__pthread_exit)
 strong_alias (__pthread_exit, pthread_exit)
 
 void __pthread_do_exit(void *retval, char *currentframe)
@@ -91,6 +95,7 @@ void __pthread_do_exit(void *retval, char *currentframe)
      or running atexit functions. */
   _exit(0);
 }
+libpthread_hidden_def(__pthread_do_exit)
 
 /* Function called by pthread_cancel to remove the thread from
    waiting on a condition variable queue. */
diff --git a/libpthread/linuxthreads/mutex.c b/libpthread/linuxthreads/mutex.c
index 3c97ea7..af9c0eb 100644
--- a/libpthread/linuxthreads/mutex.c
+++ b/libpthread/linuxthreads/mutex.c
@@ -25,6 +25,12 @@
 #include "queue.h"
 #include "restart.h"
 
+libpthread_hidden_proto(__pthread_mutex_destroy)
+libpthread_hidden_proto(__pthread_mutex_init)
+libpthread_hidden_proto(__pthread_mutex_lock)
+libpthread_hidden_proto(__pthread_mutex_trylock)
+libpthread_hidden_proto(__pthread_mutex_unlock)
+
 int __pthread_mutex_init(pthread_mutex_t * mutex,
                        const pthread_mutexattr_t * mutex_attr)
 {
@@ -35,6 +41,7 @@ int __pthread_mutex_init(pthread_mutex_t * mutex,
   mutex->__m_owner = NULL;
   return 0;
 }
+libpthread_hidden_def(__pthread_mutex_init)
 strong_alias (__pthread_mutex_init, pthread_mutex_init)
 
 int __pthread_mutex_destroy(pthread_mutex_t * mutex)
@@ -54,6 +61,7 @@ int __pthread_mutex_destroy(pthread_mutex_t * mutex)
     return EINVAL;
   }
 }
+libpthread_hidden_def(__pthread_mutex_destroy)
 strong_alias (__pthread_mutex_destroy, pthread_mutex_destroy)
 
 int __pthread_mutex_trylock(pthread_mutex_t * mutex)
@@ -90,6 +98,7 @@ int __pthread_mutex_trylock(pthread_mutex_t * mutex)
     return EINVAL;
   }
 }
+libpthread_hidden_def(__pthread_mutex_trylock)
 strong_alias (__pthread_mutex_trylock, pthread_mutex_trylock)
 
 int __pthread_mutex_lock(pthread_mutex_t * mutex)
@@ -123,6 +132,7 @@ int __pthread_mutex_lock(pthread_mutex_t * mutex)
     return EINVAL;
   }
 }
+libpthread_hidden_def(__pthread_mutex_lock)
 strong_alias (__pthread_mutex_lock, pthread_mutex_lock)
 
 int __pthread_mutex_timedlock (pthread_mutex_t *mutex,
@@ -198,6 +208,7 @@ int __pthread_mutex_unlock(pthread_mutex_t * mutex)
     return EINVAL;
   }
 }
+libpthread_hidden_def(__pthread_mutex_unlock)
 strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
 
 int __pthread_mutexattr_init(pthread_mutexattr_t *attr)
diff --git a/libpthread/linuxthreads/ptcleanup.c b/libpthread/linuxthreads/ptcleanup.c
index 75bb7d5..4189ace 100644
--- a/libpthread/linuxthreads/ptcleanup.c
+++ b/libpthread/linuxthreads/ptcleanup.c
@@ -40,6 +40,8 @@ demangle_ptr (uintptr_t x)
 #define demangle_ptr(x) x
 #endif
 
+libpthread_hidden_proto(__pthread_cleanup_upto)
+
 void __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
 {
   pthread_descr self = thread_self();
@@ -72,3 +74,4 @@ void __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
 			 demangle_ptr))
     THREAD_SETMEM(self, p_in_sighandler, NULL);
 }
+libpthread_hidden_def(__pthread_cleanup_upto)
diff --git a/libpthread/linuxthreads/ptfork.c b/libpthread/linuxthreads/ptfork.c
index 853aeea..0beb859 100644
--- a/libpthread/linuxthreads/ptfork.c
+++ b/libpthread/linuxthreads/ptfork.c
@@ -25,6 +25,8 @@
 
 extern int __libc_fork (void);
 
+libpthread_hidden_proto(__pthread_fork)
+
 pid_t __pthread_fork (struct fork_block *b)
 {
   pid_t pid;
@@ -77,6 +79,7 @@ pid_t __pthread_fork (struct fork_block *b)
 
   return pid;
 }
+libpthread_hidden_def(__pthread_fork)
 
 /* psm: have no idea why these are here, sjhill? */
 #if 0 /*def SHARED*/
diff --git a/libpthread/linuxthreads/pthread.c b/libpthread/linuxthreads/pthread.c
index 66efe3a..6397dc8 100644
--- a/libpthread/linuxthreads/pthread.c
+++ b/libpthread/linuxthreads/pthread.c
@@ -226,6 +226,61 @@ static void pthread_initialize(void) __attribute__((constructor));
 extern void *__dso_handle __attribute__ ((weak));
 #endif
 
+libpthread_hidden_proto(__pthread_fork)
+
+libpthread_hidden_proto(__pthread_attr_destroy)
+libpthread_hidden_proto(__pthread_attr_init)
+libpthread_hidden_proto(__pthread_attr_getdetachstate)
+libpthread_hidden_proto(__pthread_attr_setdetachstate)
+libpthread_hidden_proto(__pthread_attr_getinheritsched)
+libpthread_hidden_proto(__pthread_attr_setinheritsched)
+libpthread_hidden_proto(__pthread_attr_getschedparam)
+libpthread_hidden_proto(__pthread_attr_setschedparam)
+libpthread_hidden_proto(__pthread_attr_getschedpolicy)
+libpthread_hidden_proto(__pthread_attr_setschedpolicy)
+libpthread_hidden_proto(__pthread_attr_getscope)
+libpthread_hidden_proto(__pthread_attr_setscope)
+
+libpthread_hidden_proto(__pthread_condattr_destroy)
+libpthread_hidden_proto(__pthread_condattr_init)
+libpthread_hidden_proto(__pthread_cond_broadcast)
+libpthread_hidden_proto(__pthread_cond_destroy)
+libpthread_hidden_proto(__pthread_cond_init)
+libpthread_hidden_proto(__pthread_cond_signal)
+libpthread_hidden_proto(__pthread_cond_wait)
+libpthread_hidden_proto(__pthread_cond_timedwait)
+
+libpthread_hidden_proto(__pthread_equal)
+
+libpthread_hidden_proto(__pthread_exit)
+
+libpthread_hidden_proto(__pthread_getschedparam)
+libpthread_hidden_proto(__pthread_setschedparam)
+
+libpthread_hidden_proto(__pthread_mutex_destroy)
+libpthread_hidden_proto(__pthread_mutex_init)
+libpthread_hidden_proto(__pthread_mutex_lock)
+libpthread_hidden_proto(__pthread_mutex_trylock)
+libpthread_hidden_proto(__pthread_mutex_unlock)
+
+libpthread_hidden_proto(__pthread_self)
+
+libpthread_hidden_proto(__pthread_setcancelstate)
+libpthread_hidden_proto(__pthread_setcanceltype)
+
+libpthread_hidden_proto(__pthread_do_exit)
+libpthread_hidden_proto(__pthread_thread_self)
+
+libpthread_hidden_proto(__pthread_cleanup_upto)
+
+libpthread_hidden_proto(__pthread_sigaction)
+libpthread_hidden_proto(__pthread_sigwait)
+libpthread_hidden_proto(__pthread_raise)
+
+libpthread_hidden_proto(_pthread_cleanup_push)
+libpthread_hidden_proto(_pthread_cleanup_push_defer)
+libpthread_hidden_proto(_pthread_cleanup_pop)
+libpthread_hidden_proto(_pthread_cleanup_pop_restore)
 
 #if defined USE_TLS && !defined SHARED
 extern void __libc_setup_tls (size_t tcbsize, size_t tcbalign);
@@ -856,18 +911,21 @@ pthread_descr __pthread_thread_self(void)
 {
   return thread_self();
 }
+libpthread_hidden_def(__pthread_thread_self)
 
 pthread_t __pthread_self(void)
 {
   pthread_descr self = thread_self();
   return THREAD_GETMEM(self, p_tid);
 }
+libpthread_hidden_def(__pthread_self)
 strong_alias (__pthread_self, pthread_self)
 
 int __pthread_equal(pthread_t thread1, pthread_t thread2)
 {
   return thread1 == thread2;
 }
+libpthread_hidden_def(__pthread_equal)
 strong_alias (__pthread_equal, pthread_equal)
 
 /* Helper function for thread_self in the case of user-provided stacks */
@@ -949,6 +1007,7 @@ int __pthread_setschedparam(pthread_t thread, int policy,
     __pthread_manager_adjust_prio(th->p_priority);
   return 0;
 }
+libpthread_hidden_def(__pthread_setschedparam)
 strong_alias (__pthread_setschedparam, pthread_setschedparam)
 
 int __pthread_getschedparam(pthread_t thread, int *policy,
@@ -970,6 +1029,7 @@ int __pthread_getschedparam(pthread_t thread, int *policy,
   *policy = pol;
   return 0;
 }
+libpthread_hidden_def(__pthread_getschedparam)
 strong_alias (__pthread_getschedparam, pthread_getschedparam)
 
 /* Process-wide exit() request */
diff --git a/libpthread/linuxthreads/signals.c b/libpthread/linuxthreads/signals.c
index 61b411a..af9be8c 100644
--- a/libpthread/linuxthreads/signals.c
+++ b/libpthread/linuxthreads/signals.c
@@ -23,6 +23,10 @@
 /* mods for uClibc: __libc_sigaction is not in any standard headers */
 extern __typeof(sigaction) __libc_sigaction;
 
+libpthread_hidden_proto(__pthread_sigaction)
+libpthread_hidden_proto(__pthread_sigwait)
+libpthread_hidden_proto(__pthread_raise)
+
 int pthread_sigmask(int how, const sigset_t * newmask, sigset_t * oldmask)
 {
   sigset_t mask;
@@ -132,6 +136,7 @@ int __pthread_sigaction(int sig, const struct sigaction * act,
     }
   return 0;
 }
+libpthread_hidden_def(__pthread_sigaction)
 #ifdef SHARED
 strong_alias(__pthread_sigaction, __sigaction)
 strong_alias(__pthread_sigaction, sigaction)
@@ -190,6 +195,7 @@ int __pthread_sigwait(const sigset_t * set, int * sig)
   *sig = THREAD_GETMEM(self, p_signal);
   return 0;
 }
+libpthread_hidden_def(__pthread_sigwait)
 #ifdef SHARED
 strong_alias (__pthread_sigwait, sigwait)
 #endif
@@ -206,6 +212,7 @@ int __pthread_raise (int sig)
     return -1;
   }
 }
+libpthread_hidden_def(__pthread_raise)
 #ifdef SHARED
 strong_alias (__pthread_raise, raise)
 #endif
diff --git a/libpthread/linuxthreads/sysdeps/metag/pspinlock.c b/libpthread/linuxthreads/sysdeps/metag/pspinlock.c
new file mode 100644
index 0000000..4023af5
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/metag/pspinlock.c
@@ -0,0 +1,67 @@
+/* POSIX spinlock implementation.  META version.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include "internals.h"
+
+int
+__pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  while (testandset((int *)lock));
+
+  return 0;
+}
+weak_alias (__pthread_spin_lock, pthread_spin_lock)
+
+
+int
+__pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  return testandset((int *)lock) ? EBUSY : 0;
+}
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
+
+
+int
+__pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  return *lock = 0;
+}
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
+
+
+int
+__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
+     all processes which can access the memory location `lock' points
+     to can use the spinlock.  */
+  return *lock = 0;
+}
+weak_alias (__pthread_spin_init, pthread_spin_init)
+
+
+int
+__pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+  /* Nothing to do.  */
+  return 0;
+}
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/metag/pt-machine.h b/libpthread/linuxthreads/sysdeps/metag/pt-machine.h
new file mode 100644
index 0000000..b11c448
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/metag/pt-machine.h
@@ -0,0 +1,76 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   META version.
+   Copyright (C) 2006-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+#ifndef __ASSEMBLER__
+#ifndef PT_EI
+# define PT_EI __extern_always_inline
+#endif
+
+#define ISLOCKED	1
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+#ifndef __CONFIG_META_2_1__
+extern int metag_spinlock(int *spinlock);
+#endif
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+#ifndef __CONFIG_META_2_1__
+        return metag_spinlock(spinlock);
+#else
+	register unsigned int ret __asm__("D0Re0") = 0;
+
+	__asm__ __volatile__(
+		"       LNKGETD %0,[%2]\n"
+		"       TST     %0, %1\n"
+		"       ADD     %0, %0, %1\n"
+		"       LNKSETDZ [%2], %0\n"
+		"       BNZ     1f\n"
+		"       DEFR    %0, TXSTAT\n"
+		"	ANDT	%0, %0, #HI(0x3f000000)\n"
+		"	CMPT	%0, #HI(0x02000000)\n"
+                "       MOV     %0, #1\n"
+		"1:	XORZ    %0, %0, %0\n"
+		: "=&da"(ret)
+		: "K"(ISLOCKED), "da"(spinlock)
+		: "cc");
+	return ret;
+
+#endif /* __CONFIG_META_2_1__ */
+}
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("A0StP");
+
+#define MAX_SPIN_COUNT 8
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/metag/tls.h b/libpthread/linuxthreads/sysdeps/metag/tls.h
new file mode 100644
index 0000000..5045825
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/metag/tls.h
@@ -0,0 +1,187 @@
+/* Definition for thread-local data handling.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+
+/* An architecture-specific version of this file has to defined a
+   number of symbols:
+
+     TLS_TCB_AT_TP  or  TLS_DTV_AT_TP
+
+     The presence of one of these symbols signals which variant of
+     the TLS ABI is used.  There are in the moment two variants
+     available:
+
+     * the thread pointer points to a thread control block
+
+     * the thread pointer points to the dynamic thread vector
+
+
+     TLS_TCB_SIZE
+
+     This is the size of the thread control block structure.  How
+     this is actually defined depends on the ABI.  The thread control
+     block could be internal descriptor of the thread library or
+     just a data structure which allows finding the DTV.
+
+     TLS_INIT_TCB_SIZE
+
+     Similarly, but this value is only used at startup and in the
+     dynamic linker itself.  There are no threads in use at that time.
+
+
+     TLS_TCB_ALIGN
+
+     Alignment requirements for the TCB structure.
+
+     TLS_INIT_TCB_ALIGN
+
+     Similarly, but for the structure used at startup time.
+
+
+     INSTALL_DTV(tcb, init_dtv)
+
+     This macro must install the given initial DTV into the thread control
+     block TCB.  The normal runtime functionality must then be able to
+     use the value.
+
+
+     TLS_INIT_TP(tcb, firstcall)
+
+     This macro must initialize the thread pointer to enable normal TLS
+     operation.  The first parameter is a pointer to the thread control
+     block.  The second parameter specifies whether this is the first
+     call for the TCB.  ld.so calls this macro more than once.
+
+
+     THREAD_DTV()
+
+     This macro returns the address of the DTV of the current thread.
+     This normally is done using the the thread register which points
+     to the dtv or the TCB (from which the DTV can found).
+  */
+# include <pt-machine.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+/* We can support TLS only if the floating-stack support is available.  */
+#if defined HAVE_TLS_SUPPORT \
+    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+
+/* Signal that TLS support is available.  */
+# define USE_TLS	1
+
+/* Include padding in _pthread_descr_struct so that libc can find p_errno,
+   if libpthread will only include the padding because of the !IS_IN_libpthread
+   check.  */
+#ifndef FLOATING_STACKS
+# define INCLUDE_TLS_PADDING	1
+#endif
+
+# ifndef __ASSEMBLER__
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+#  define TLS_TCB_SIZE sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+#  define TLS_PRE_TCB_SIZE sizeof (struct _pthread_descr_struct)
+
+/* Alignment requirements for the TCB.  */
+#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
+
+/* The TLS blocks start right after the TCB.  */
+#  define TLS_DTV_AT_TP	1
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+#  define INSTALL_DTV(tcbp, dtvp) \
+  ((tcbhead_t *) (tcbp))->dtv = dtvp + 1
+
+/* Install new dtv for current thread.  */
+#  define INSTALL_NEW_DTV(DTV) \
+  (((tcbhead_t *)__builtin_thread_pointer ())->dtv = (DTV))
+
+/* Return dtv of given thread descriptor.  */
+#  define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+#  define TLS_INIT_TP(tcbp, secondcall) \
+  ({ INTERNAL_SYSCALL_DECL (err);					\
+     long result_var;							\
+     result_var = INTERNAL_SYSCALL (metag_set_tls, err, 1, (TCBP));	\
+     INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
+       ? "unknown error" : NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+#  define THREAD_DTV() \
+  (((tcbhead_t *)__builtin_thread_pointer ())->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+#  undef THREAD_SELF
+#  define THREAD_SELF \
+  ((pthread_descr)__builtin_thread_pointer () - 1)
+
+#  undef INIT_THREAD_SELF
+#  define INIT_THREAD_SELF(DESCR, NR) \
+  TLS_INIT_TP ((struct _pthread_descr_struct *)(DESCR) + 1, 0)
+
+/* Get the thread descriptor definition.  This must be after the
+   the definition of THREAD_SELF for TLS.  */
+#  include <linuxthreads/descr.h>
+
+# endif /* __ASSEMBLER__ */
+
+#endif	/* HAVE_TLS_SUPPORT && (FLOATING_STACKS || !IS_IN_libpthread) */
+
+#endif	/* tls.h */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h b/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
index 80d33be..3e1d101 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
@@ -22,10 +22,19 @@
 #include <sysdep.h>
 
 /* Uncancelable open.  */
+#if defined(__NR_openat) && ! defined(__NR_open)
+#define open_not_cancel(name, flags, mode) \
+	INLINE_SYSCALL (openat, 4, (int) (AT_FDCWD), (const char *) (name), \
+		(flags), (mode))
+#define open_not_cancel_2(name, flags) \
+	INLINE_SYSCALL (openat, 3, (int) (AT_FDCWD), (const char *) (name), \
+		(flags))
+#else
 #define open_not_cancel(name, flags, mode) \
    INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
 #define open_not_cancel_2(name, flags) \
    INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+#endif
 
 /* Uncancelable openat.  */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
diff --git a/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h b/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h
index b957ded..8e8b04e 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h
@@ -3,7 +3,6 @@
 
 #include <features.h>
 #include <sys/cdefs.h>
-#include <bits/uClibc_page.h>
 
 #ifdef IS_IN_libpthread
 #include <bits/kernel-features.h>
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h
new file mode 100644
index 0000000..a5dbeff
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h
@@ -0,0 +1,187 @@
+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include <pt-machine.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_CALL (syscall_name, args);					      \
+    cmpl $-4095, %eax;							      \
+    jae SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    CENABLE								      \
+    SAVE_OLDTYPE_##args							      \
+    PUSHCARGS_##args							      \
+    DOCARGS_##args							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80								      \
+    POPCARGS_##args;							      \
+    POPSTATE_##args							      \
+    cmpl $-4095, %eax;							      \
+    jae SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+# define SAVE_OLDTYPE_0	movl %eax, %ecx;
+# define SAVE_OLDTYPE_1	SAVE_OLDTYPE_0
+# define SAVE_OLDTYPE_2	pushl %eax; cfi_adjust_cfa_offset (4);
+# define SAVE_OLDTYPE_3	SAVE_OLDTYPE_2
+# define SAVE_OLDTYPE_4	SAVE_OLDTYPE_2
+# define SAVE_OLDTYPE_5	SAVE_OLDTYPE_2
+
+# define PUSHCARGS_0	/* No arguments to push.  */
+# define DOCARGS_0	/* No arguments to frob.  */
+# define POPCARGS_0	/* No arguments to pop.  */
+# define _PUSHCARGS_0	/* No arguments to push.  */
+# define _POPCARGS_0	/* No arguments to pop.  */
+
+# define PUSHCARGS_1	movl %ebx, %edx; cfi_register (ebx, edx); PUSHCARGS_0
+# define DOCARGS_1	_DOARGS_1 (4)
+# define POPCARGS_1	POPCARGS_0; movl %edx, %ebx; cfi_restore (ebx);
+# define _PUSHCARGS_1	pushl %ebx; cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (ebx, 0); _PUSHCARGS_0
+# define _POPCARGS_1	_POPCARGS_0; popl %ebx; \
+			cfi_adjust_cfa_offset (-4); cfi_restore (ebx);
+
+# define PUSHCARGS_2	PUSHCARGS_1
+# define DOCARGS_2	_DOARGS_2 (12)
+# define POPCARGS_2	POPCARGS_1
+# define _PUSHCARGS_2	_PUSHCARGS_1
+# define _POPCARGS_2	_POPCARGS_1
+
+# define PUSHCARGS_3	_PUSHCARGS_2
+# define DOCARGS_3	_DOARGS_3 (20)
+# define POPCARGS_3	_POPCARGS_3
+# define _PUSHCARGS_3	_PUSHCARGS_2
+# define _POPCARGS_3	_POPCARGS_2
+
+# define PUSHCARGS_4	_PUSHCARGS_4
+# define DOCARGS_4	_DOARGS_4 (28)
+# define POPCARGS_4	_POPCARGS_4
+# define _PUSHCARGS_4	pushl %esi; cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (esi, 0); _PUSHCARGS_3
+# define _POPCARGS_4	_POPCARGS_3; popl %esi; \
+			cfi_adjust_cfa_offset (-4); cfi_restore (esi);
+
+# define PUSHCARGS_5	_PUSHCARGS_5
+# define DOCARGS_5	_DOARGS_5 (36)
+# define POPCARGS_5	_POPCARGS_5
+# define _PUSHCARGS_5	pushl %edi; cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (edi, 0); _PUSHCARGS_4
+# define _POPCARGS_5	_POPCARGS_4; popl %edi; \
+			cfi_adjust_cfa_offset (-4); cfi_restore (edi);
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel
+# elif defined IS_IN_librt
+#  ifdef PIC
+#   define CENABLE	pushl %ebx; \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_enable_asynccancel@PLT; \
+			popl %ebx;
+#   define CDISABLE	pushl %ebx; \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_disable_asynccancel@PLT; \
+			popl %ebx;
+#  else
+#   define CENABLE	call __librt_enable_asynccancel;
+#   define CDISABLE	call __librt_disable_asynccancel
+#  endif
+# else
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel
+# endif
+# define POPSTATE_0 \
+ pushl %eax; cfi_adjust_cfa_offset (4); movl %ecx, %eax; \
+ CDISABLE; popl %eax; cfi_adjust_cfa_offset (-4);
+# define POPSTATE_1	POPSTATE_0
+# define POPSTATE_2	xchgl (%esp), %eax; CDISABLE; popl %eax; \
+			cfi_adjust_cfa_offset (-4);
+# define POPSTATE_3	POPSTATE_2
+# define POPSTATE_4	POPSTATE_3
+# define POPSTATE_5	POPSTATE_4
+
+#if !defined NOT_IN_libc
+# define __local_multiple_threads __libc_multiple_threads
+#elif defined IS_IN_libpthread
+# define __local_multiple_threads __pthread_multiple_threads
+#else
+# define __local_multiple_threads __librt_multiple_threads
+#endif
+
+# ifndef __ASSEMBLER__
+#  if defined FLOATING_STACKS && USE___THREAD && defined PIC
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
+				   p_header.data.multiple_threads) == 0, 1)
+#  else
+extern int __local_multiple_threads
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+  attribute_hidden;
+#   else
+  ;
+#   endif
+#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+#  endif
+# else
+#  if !defined PIC
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads
+#  elif defined FLOATING_STACKS && USE___THREAD
+#   define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
+#  else
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+#    define __SINGLE_THREAD_CMP cmpl $0, __local_multiple_threads@GOTOFF(%ecx)
+#   else
+#    define __SINGLE_THREAD_CMP \
+  movl __local_multiple_threads@GOT(%ecx), %ecx;\
+  cmpl $0, (%ecx)
+#   endif
+#   if !defined HAVE_HIDDEN || !USE___THREAD
+#    define SINGLE_THREAD_P \
+  SETUP_PIC_REG (cx);				\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   else
+#    define SINGLE_THREAD_P \
+  call __i686.get_pc_thunk.cx;			\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   endif
+#  endif
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+
+#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/vfork.S
new file mode 100644
index 0000000..c7a120d
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/metag/vfork.S
@@ -0,0 +1,95 @@
+/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Schwab <schwab@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <kernel-features.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef __NR_vfork
+
+# ifdef SHARED
+#  if !defined HAVE_HIDDEN || !USE___THREAD
+	SETUP_PIC_REG (cx)
+#  else
+	call	__i686.get_pc_thunk.cx
+#  endif
+	addl	$_GLOBAL_OFFSET_TABLE_, %ecx
+	cmpl	$0, __libc_pthread_functions@GOTOFF(%ecx)
+# else
+	.weak	pthread_create
+	movl	$pthread_create, %eax
+	testl	%eax, %eax
+# endif
+	jne	HIDDEN_JUMPTARGET (__fork)
+
+	/* Pop the return PC value into ECX.  */
+	popl	%ecx
+
+	/* Stuff the syscall number in EAX and enter into the kernel.  */
+	movl	$SYS_ify (vfork), %eax
+	int	$0x80
+
+	/* Jump to the return PC.  Don't jump directly since this
+	   disturbs the branch target cache.  Instead push the return
+	   address back on the stack.  */
+	pushl	%ecx
+
+	cmpl	$-4095, %eax
+	/* Branch forward if it failed.  */
+# ifdef __ASSUME_VFORK_SYSCALL
+	jae	SYSCALL_ERROR_LABEL
+.Lpseudo_end:
+# else
+	jae	.Lerror
+# endif
+
+	ret
+
+# ifndef __ASSUME_VFORK_SYSCALL
+.Lerror:
+	/* Check if vfork syscall is known at all.  */
+	cmpl	$-ENOSYS, %eax
+	jne	SYSCALL_ERROR_LABEL
+# endif
+#endif
+
+#ifndef __ASSUME_VFORK_SYSCALL
+	/* If we don't have vfork, fork is close enough.  */
+
+	movl	$SYS_ify (fork), %eax
+	int	$0x80
+	cmpl	$-4095, %eax
+	jae	SYSCALL_ERROR_LABEL
+.Lpseudo_end:
+	ret
+#elif !defined __NR_vfork
+# error "__NR_vfork not available and __ASSUME_VFORK_SYSCALL defined"
+#endif
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
diff --git a/libpthread/nptl/Makefile.in b/libpthread/nptl/Makefile.in
index 158bcae..0008822 100644
--- a/libpthread/nptl/Makefile.in
+++ b/libpthread/nptl/Makefile.in
@@ -145,7 +145,7 @@ LDFLAGS-libpthread.so += $(LDFLAGS)
 endif
 
 LDFLAGS-libpthread.so += $(top_builddir)lib/$(UCLIBC_LDSO_NAME)-$(VERSION).so $(top_builddir)lib/libdl-$(VERSION).so \
-	-Wl,-z,nodelete,-z,initfirst,-init=__pthread_initialize_minimal_internal
+	-Wl,-z,nodelete,-z,initfirst,-init=$(SYMBOL_PREFIX)__pthread_initialize_minimal_internal
 
 LIBS-libpthread.so := $(LIBS)
 
diff --git a/libpthread/nptl/allocatestack.c b/libpthread/nptl/allocatestack.c
index e30fe41..fbcaccd 100644
--- a/libpthread/nptl/allocatestack.c
+++ b/libpthread/nptl/allocatestack.c
@@ -16,7 +16,6 @@
    License along with the GNU C Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
-
 #include <assert.h>
 #include <errno.h>
 #include <signal.h>
@@ -646,7 +645,7 @@ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
 			prot) != 0)
 	    goto mprot_error;
 #elif defined _STACK_GROWS_UP
-	  if (mprotect ((char *) pd - pd->guardsize,
+	  if (mprotect ((char *) (((uintptr_t) pd - pd->guardsize) & ~pagesize_m1),
 			pd->guardsize - guardsize, prot) != 0)
 	    goto mprot_error;
 #endif
diff --git a/libpthread/nptl/cleanup_defer_compat.c b/libpthread/nptl/cleanup_defer_compat.c
index 95fa4a0..2fcb532 100644
--- a/libpthread/nptl/cleanup_defer_compat.c
+++ b/libpthread/nptl/cleanup_defer_compat.c
@@ -22,7 +22,7 @@
 
 void
 attribute_protected
-_pthread_cleanup_push_defer (
+__pthread_cleanup_push_defer (
      struct _pthread_cleanup_buffer *buffer,
      void (*routine) (void *),
      void *arg)
@@ -57,12 +57,12 @@ _pthread_cleanup_push_defer (
 
   THREAD_SETMEM (self, cleanup, buffer);
 }
-strong_alias (_pthread_cleanup_push_defer, __pthread_cleanup_push_defer)
+strong_alias (__pthread_cleanup_push_defer, _pthread_cleanup_push_defer)
 
 
 void
 attribute_protected
-_pthread_cleanup_pop_restore (
+__pthread_cleanup_pop_restore (
      struct _pthread_cleanup_buffer *buffer,
      int execute)
 {
@@ -97,4 +97,4 @@ _pthread_cleanup_pop_restore (
   if (execute)
     buffer->__routine (buffer->__arg);
 }
-strong_alias (_pthread_cleanup_pop_restore, __pthread_cleanup_pop_restore)
+strong_alias (__pthread_cleanup_pop_restore, _pthread_cleanup_pop_restore)
diff --git a/libpthread/nptl/init.c b/libpthread/nptl/init.c
index c8ca096..2bbcfb4 100644
--- a/libpthread/nptl/init.c
+++ b/libpthread/nptl/init.c
@@ -112,8 +112,8 @@ static const struct pthread_functions pthread_functions =
     .ptr___pthread_key_create = __pthread_key_create_internal,
     .ptr___pthread_getspecific = __pthread_getspecific_internal,
     .ptr___pthread_setspecific = __pthread_setspecific_internal,
-    .ptr__pthread_cleanup_push_defer = _pthread_cleanup_push_defer,
-    .ptr__pthread_cleanup_pop_restore = _pthread_cleanup_pop_restore,
+    .ptr__pthread_cleanup_push_defer = __pthread_cleanup_push_defer,
+    .ptr__pthread_cleanup_pop_restore = __pthread_cleanup_pop_restore,
     .ptr_nthreads = &__nptl_nthreads,
     .ptr___pthread_unwind = &__pthread_unwind,
     .ptr__nptl_deallocate_tsd = __nptl_deallocate_tsd,
diff --git a/libpthread/nptl/sysdeps/metag/Makefile.arch b/libpthread/nptl/sysdeps/metag/Makefile.arch
new file mode 100644
index 0000000..9f373d2
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/Makefile.arch
@@ -0,0 +1,17 @@
+# Makefile for uClibc NPTL
+#
+# Copyright (C) 2005 Steven J. Hill <sjhill@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CFLAGS-pthread_spin_init.c = -DNOT_IN_libc -DIS_IN_libpthread
+ASFLAGS-pthread_spin_lock.S = -DNOT_IN_libc -DIS_IN_libpthread
+ASFLAGS-pthread_spin_unlock.S = -DNOT_IN_libc -DIS_IN_libpthread
+ASFLAGS-pthread_spin_trylock.S = -DNOT_IN_libc -DIS_IN_libpthread
+
+ASFLAGS-pthread_spin_lock.c += -D_GNU_SOURCE
+
+CFLAGS-metag = $(SSP_ALL_CFLAGS)
+
+libc_arch_a_CSRC := libc-tls.c
diff --git a/libpthread/nptl/sysdeps/metag/dl-tls.h b/libpthread/nptl/sysdeps/metag/dl-tls.h
new file mode 100644
index 0000000..4cedd10
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/dl-tls.h
@@ -0,0 +1,29 @@
+/* Thread-local storage handling in the ELF dynamic linker.  META version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
diff --git a/libpthread/nptl/sysdeps/metag/jmpbuf-unwind.h b/libpthread/nptl/sysdeps/metag/jmpbuf-unwind.h
new file mode 100644
index 0000000..eedf794
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/jmpbuf-unwind.h
@@ -0,0 +1,36 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#undef _JMPBUF_UNWINDS
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
+  ((void *) (address) > (void *) demangle (jmpbuf[JB_SP]))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) > (uintptr_t) (_jmpbuf)[JB_SP] - (_adj))
+
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/libpthread/nptl/sysdeps/metag/libc-tls.c b/libpthread/nptl/sysdeps/metag/libc-tls.c
new file mode 100644
index 0000000..80144f8
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/libc-tls.c
@@ -0,0 +1,31 @@
+/*
+ * Thread-local storage handling in statically linked binaries.  META version.
+ * Copyright (C) 2009 Free Software Foundation, Inc.
+ *
+ * Based on GNU C Library (file: libc/sysdeps/sh/libc-tls.c)
+ *
+ * Copyright (C) 2010 STMicroelectronics Ltd.
+ * Author: Filippo Arcidiacono <filippo.arcidiacono@st.com>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ *
+ */
+
+#include <sysdeps/generic/libc-tls.c>
+#include <dl-tls.h>
+
+#if defined (USE_TLS) && (USE_TLS)
+
+/* On META, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
+
+#endif
diff --git a/libpthread/nptl/sysdeps/metag/metag_load_tp.S b/libpthread/nptl/sysdeps/metag/metag_load_tp.S
new file mode 100644
index 0000000..8029f22
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/metag_load_tp.S
@@ -0,0 +1 @@
+#include <../../../../ldso/ldso/metag/metag_load_tp.S>
diff --git a/libpthread/nptl/sysdeps/metag/pthread_spin_init.c b/libpthread/nptl/sysdeps/metag/pthread_spin_init.c
new file mode 100644
index 0000000..0a47981
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/pthread_spin_init.c
@@ -0,0 +1,20 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Not needed.  pthread_spin_init is an alias for pthread_spin_unlock.  */
diff --git a/libpthread/nptl/sysdeps/metag/pthread_spin_lock.S b/libpthread/nptl/sysdeps/metag/pthread_spin_lock.S
new file mode 100644
index 0000000..d369dc6
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/pthread_spin_lock.S
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+	.text
+	.global	_pthread_spin_lock
+	.type	_pthread_spin_lock,function
+_pthread_spin_lock:
+1:	LNKGETD	D0Ar2, [D1Ar1]
+	CMP	D0Ar2, #0
+	ADD	D0Ar2, D0Ar2, #1
+	LNKSETDEQ [D1Ar1], D0Ar2
+	BNE	1b
+	DEFR	D0Ar2, TXSTAT
+	ANDT	D0Ar2, D0Ar2, #HI(0x3f000000)
+	CMPT	D0Ar2, #HI(0x02000000)
+	BNZ	1b
+	MOV	D0Re0, #0
+	MOV	PC, D1RtP
+        .size   _pthread_spin_lock,.-_pthread_spin_lock
diff --git a/libpthread/nptl/sysdeps/metag/pthread_spin_trylock.S b/libpthread/nptl/sysdeps/metag/pthread_spin_trylock.S
new file mode 100644
index 0000000..49974ca
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/pthread_spin_trylock.S
@@ -0,0 +1,37 @@
+/* Copyright (C) 2011-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <pthread-errnos.h>
+
+	.text
+	.global	_pthread_spin_trylock
+	.type	_pthread_spin_trylock,function
+_pthread_spin_trylock:
+1:	MOVT	D0Re0, #HI(#EBUSY)
+	ADD	D0Re0, D0Re0, #LO(#EBUSY)
+	LNKGETD	D0Ar2, [D1Ar1]
+	CMP	D0Ar2, #0
+	ADD	D0Ar2, D0Ar2, #1
+	LNKSETDEQ [D1Ar1], D0Ar2
+	BNE	2f
+	DEFR	D0Ar2, TXSTAT
+	ANDT	D0Ar2, D0Ar2, #HI(0x3f000000)
+	CMPT	D0Ar2, #HI(0x02000000)
+	BNZ	1b
+	MOV	D0Re0, #0
+2:	MOV	PC, D1RtP
+        .size   _pthread_spin_trylock,.-_pthread_spin_trylock
diff --git a/libpthread/nptl/sysdeps/metag/pthread_spin_unlock.S b/libpthread/nptl/sysdeps/metag/pthread_spin_unlock.S
new file mode 100644
index 0000000..8dca674
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/pthread_spin_unlock.S
@@ -0,0 +1,29 @@
+/* Copyright (C) 2011-2012 Imagination Technologies Ltd.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+	.text
+	.global	_pthread_spin_unlock
+	.type	_pthread_spin_unlock,function
+_pthread_spin_unlock:
+	MOV	D0Re0, #0
+	SETD	[D1Ar1], D0Re0
+	MOV	PC, D1RtP
+        .size   _pthread_spin_unlock,.-_pthread_spin_unlock
+
+        /* The implementation of pthread_spin_init is identical.  */
+        .global  _pthread_spin_init
+_pthread_spin_init = _pthread_spin_unlock
diff --git a/libpthread/nptl/sysdeps/metag/pthreaddef.h b/libpthread/nptl/sysdeps/metag/pthreaddef.h
new file mode 100644
index 0000000..51625e4
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/pthreaddef.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		8
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		8
+
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff --git a/libpthread/nptl/sysdeps/metag/tcb-offsets.sym b/libpthread/nptl/sysdeps/metag/tcb-offsets.sym
new file mode 100644
index 0000000..753b72b
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/tcb-offsets.sym
@@ -0,0 +1,15 @@
+#include <sysdep.h>
+#include <tls.h>
+
+RESULT			offsetof (struct pthread, result)
+TID			offsetof (struct pthread, tid)
+PID			offsetof (struct pthread, pid)
+CANCELHANDLING		offsetof (struct pthread, cancelhandling)
+CLEANUP_JMP_BUF		offsetof (struct pthread, cleanup_jmp_buf)
+MULTIPLE_THREADS_OFFSET	offsetof (struct pthread, header.multiple_threads)
+TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+MUTEX_FUTEX		offsetof (pthread_mutex_t, __data.__lock)
+POINTER_GUARD		offsetof (tcbhead_t, pointer_guard)
+#ifndef __ASSUME_PRIVATE_FUTEX
+PRIVATE_FUTEX		offsetof (struct pthread, header.private_futex)
+#endif
diff --git a/libpthread/nptl/sysdeps/metag/tls.h b/libpthread/nptl/sysdeps/metag/tls.h
new file mode 100644
index 0000000..5fff40f
--- /dev/null
+++ b/libpthread/nptl/sysdeps/metag/tls.h
@@ -0,0 +1,163 @@
+/* Definition for thread-local data handling.  NPTL/META version.
+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+# include <stdlib.h>
+# include <list.h>
+# include <sysdep.h>
+# include <bits/kernel-features.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+typedef struct
+{
+  dtv_t *dtv;
+  uintptr_t pointer_guard;
+} tcbhead_t;
+
+# define TLS_MULTIPLE_THREADS_IN_TCB 1
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#define HAVE_TLS_SUPPORT
+#define HAVE___THREAD   1
+#define HAVE_TLS_MODEL_ATTRIBUTE       1
+/* Signal that TLS support is available.  */
+# define USE_TLS       1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE sizeof (struct pthread)
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN __alignof__ (struct pthread)
+
+/* The TLS blocks start right after the TCB.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <descr.h>
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  ((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (((tcbhead_t *)__builtin_thread_pointer ())->dtv = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ INTERNAL_SYSCALL_DECL (err);					\
+     long result_var;							\
+     result_var = INTERNAL_SYSCALL (metag_set_tls, err, 1, (tcbp));	\
+     INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
+       ? "unknown error" : NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *)__builtin_thread_pointer ())->dtv)
+
+/* Return the thread descriptor for the current thread.
+   The contained asm must *not* be marked volatile since otherwise
+   assignments like
+        struct pthread *self = thread_self();
+   do not get optimized away.  */
+# define THREAD_SELF \
+  ((struct pthread *)__builtin_thread_pointer () - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  descr->member
+#define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/Makefile.commonarch b/libpthread/nptl/sysdeps/unix/sysv/linux/Makefile.commonarch
index 8a762b7..ab2d6c9 100644
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/Makefile.commonarch
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/Makefile.commonarch
@@ -77,7 +77,7 @@ librt_linux_CSRC += mq_notify.c timer_create.c timer_delete.c		\
 	timer_settime.c
 
 # These provide both a cancellable and a not cancellable implementation
-libc_linux_SSRC = close.S open.S write.S read.S waitpid.S
+libc_linux_SSRC = close.S open.S openat.S write.S read.S waitpid.S
 libc_linux_SSRC := $(filter-out $(libc_linux_arch_SSRC-OMIT),$(libc_linux_SSRC))
 
 libpthread_linux_CSRC := $(filter-out $(notdir $(libpthread_linux_arch_OBJS:.o=.c)),$(libpthread_linux_CSRC))
@@ -145,6 +145,7 @@ CFLAGS-OMIT-libc-lowlevellock.c = -DNOT_IN_libc -DIS_IN_libpthread
 
 CFLAGS-OMIT-close.S = -DNOT_IN_libc -DIS_IN_libpthread
 CFLAGS-OMIT-open.S = -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-OMIT-openat.S = -DNOT_IN_libc -DIS_IN_libpthread
 CFLAGS-OMIT-read.S = -DNOT_IN_libc -DIS_IN_libpthread
 CFLAGS-OMIT-write.S = -DNOT_IN_libc -DIS_IN_libpthread
 CFLAGS-OMIT-waitpid.S = -DNOT_IN_libc -DIS_IN_libpthread
@@ -158,6 +159,7 @@ CFLAGS-OMIT-timer_routines.c = -DIS_IN_libpthread
 CFLAGS-OMIT-timer_settime.c = -DIS_IN_libpthread
 
 ASFLAGS-open.S = -D_LIBC_REENTRANT
+ASFLAGS-openat.S = -D_LIBC_REENTRANT
 ASFLAGS-close.S = -D_LIBC_REENTRANT
 ASFLAGS-read.S = -D_LIBC_REENTRANT
 ASFLAGS-write.S = -D_LIBC_REENTRANT
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile
new file mode 100644
index 0000000..43a6fad
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc NPTL
+#
+# Copyright (C) 2005 Steven J. Hill <sjhill@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir=../../../../../../../
+top_builddir=../../../../../../../
+all: objs
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile.arch b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile.arch
new file mode 100644
index 0000000..7a5c874
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/Makefile.arch
@@ -0,0 +1,34 @@
+# Makefile for uClibc NPTL
+#
+# Copyright (C) 2006 Steven J. Hill <sjhill@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+libpthread_linux_arch_SSRC = pt-vfork.S
+libpthread_linux_arch_CSRC = pthread_once.c \
+	pt-__syscall_rt_sigaction.c pt-__syscall_error.c \
+	lowlevellock.c
+
+libc_linux_arch_CSRC = fork.c libc-lowlevellock.c
+libc_linux_arch_SSRC = clone.S vfork.S
+libc_linux_arch_SSRC-OMIT = waitpid.S
+
+CFLAGS += $(SSP_ALL_CFLAGS)
+
+CFLAGS-pthread_once.c = -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-pt-__syscall_rt_sigaction.c = -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-lowlevellock.c = -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-pt-__syscall_error.c =  -DNOT_IN_libc -DIS_IN_libpthread
+ASFLAGS-vfork.S = -DIS_IN_libc -DNOT_IN_libpthread
+ASFLAGS-clone.S = -DIS_IN_libc -DNOT_IN_libpthread
+ASFLAGS-pt-vfork.S = -DNOT_IN_libc -DIS_IN_libpthread
+
+ifeq ($(UCLIBC_HAS_STDIO_FUTEXES),y)
+CFLAGS-fork.c = -D__USE_STDIO_FUTEXES__
+endif
+CFLAGS-OMIT-fork.c = -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-OMIT-libc-lowlevellock.c = -DNOT_IN_libc -DIS_IN_libpthread
+# We always compile it in arm mode because of SAVE_PID macro
+# This macro should be alternatively implemented in THUMB
+# assembly.
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/pthreadtypes.h b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/pthreadtypes.h
new file mode 100644
index 0000000..e1b115c
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/pthreadtypes.h
@@ -0,0 +1,181 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#define __SIZEOF_PTHREAD_ATTR_T 36
+#define __SIZEOF_PTHREAD_MUTEX_T 24
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_COND_T 48
+#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
+#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_RWLOCK_T 32
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#define __SIZEOF_PTHREAD_BARRIER_T 20
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  long int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  long int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/semaphore.h b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/semaphore.h
new file mode 100644
index 0000000..dadfac2
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/bits/semaphore.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	16
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/clone.S b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/clone.S
new file mode 100644
index 0000000..075743a
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/clone.S
@@ -0,0 +1,3 @@
+#define RESET_PID
+#include <tcb-offsets.h>
+#include "../../../../../../../libc/sysdeps/linux/metag/clone.S"
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/createthread.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/createthread.c
new file mode 100644
index 0000000..2d43559
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/createthread.c
@@ -0,0 +1,23 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE (pd + 1)
+
+/* Get the real implementation.	 */
+#include <sysdeps/pthread/createthread.c>
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/fork.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/fork.c
new file mode 100644
index 0000000..41776f9
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/fork.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Phil Blundell <pb@nexus.co.uk>, 2005
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+
+
+#define ARCH_FORK()							\
+  INLINE_SYSCALL (clone, 5,						\
+		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
+		  NULL, NULL, &THREAD_SELF->tid, NULL)
+
+#include "../fork.c"
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/libc-lowlevellock.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/libc-lowlevellock.c
new file mode 100644
index 0000000..b192822
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/libc-lowlevellock.c
@@ -0,0 +1,21 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* No difference to lowlevellock.c, except we lose a couple of functions.  */
+#include "lowlevellock.c"
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.c
new file mode 100644
index 0000000..8c8955e
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.c
@@ -0,0 +1,134 @@
+/* low level locking for pthread library.  Generic futex-using version.
+   Copyright (C) 2003, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <sys/time.h>
+#include <tls.h>
+
+void
+__lll_lock_wait_private (int *futex)
+{
+  do
+    {
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_wait (futex, 2, LLL_PRIVATE);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+}
+
+
+/* These functions don't get included in libc.so  */
+#ifdef IS_IN_libpthread
+void
+__lll_lock_wait (int *futex, int private)
+{
+  do
+    {
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_wait (futex, 2, private);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+}
+
+
+int
+__lll_timedlock_wait (int *futex, const struct timespec *abstime, int private)
+{
+  struct timespec rt;
+
+  /* Reject invalid timeouts.  */
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  /* Upgrade the lock.  */
+  if (atomic_exchange_acq (futex, 2) == 0)
+    return 0;
+
+  do
+    {
+      struct timeval tv;
+
+      /* Get the current time.  */
+      (void) gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      // XYZ: Lost the lock to check whether it was private.
+      lll_futex_timed_wait (futex, 2, &rt, private);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+
+  return 0;
+}
+
+
+int
+__lll_timedwait_tid (int *tidp, const struct timespec *abstime)
+{
+  int tid;
+
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  /* Repeat until thread terminated.  */
+  while ((tid = *tidp) != 0)
+    {
+      struct timeval tv;
+      struct timespec rt;
+
+      /* Get the current time.  */
+      (void) gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      /* Wait until thread terminates.  */
+      // XYZ: Lost the lock to check whether it was private.
+      if (lll_futex_timed_wait (tidp, tid, &rt, LLL_SHARED) == -ETIMEDOUT)
+	return ETIMEDOUT;
+    }
+
+  return 0;
+}
+#endif
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.h b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.h
new file mode 100644
index 0000000..4c7d08c
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/lowlevellock.h
@@ -0,0 +1,282 @@
+/* Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <bits/kernel-features.h>
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif	      
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    __ret;								      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);					      \
+    __ret;								      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+#define lll_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 1, 0)
+
+#define lll_cond_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 2, 0)
+
+#define __lll_robust_trylock(futex, id) \
+  (atomic_compare_and_exchange_val_acq (futex, id, 0) != 0)
+#define lll_robust_trylock(lock, id) \
+  __lll_robust_trylock (&(lock), id)
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+#define __lll_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_compare_and_exchange_val_acq (__futex,       \
+								1, 0), 0))    \
+      {									      \
+	if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
+	  __lll_lock_wait_private (__futex);				      \
+	else								      \
+	  __lll_lock_wait (__futex, private);				      \
+      }									      \
+  }))
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+
+#define __lll_robust_lock(futex, id, private)				      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_lock_wait (__futex, private);		      \
+    __val;								      \
+  })
+#define lll_robust_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), id, private)
+
+
+#define __lll_cond_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_exchange_acq (__futex, 2), 0))		      \
+      __lll_lock_wait (__futex, private);				      \
+  }))
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+
+#define lll_robust_cond_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+#define __lll_timedlock(futex, abstime, private)			      \
+  ({									      \
+     int *__futex = (futex);						      \
+     int __val = 0;							      \
+									      \
+     if (__builtin_expect (atomic_exchange_acq (__futex, 1), 0))	      \
+       __val = __lll_timedlock_wait (__futex, abstime, private);	      \
+     __val;								      \
+  })
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+#define __lll_robust_timedlock(futex, abstime, id, private)		      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_timedlock_wait (__futex, abstime, private);	      \
+    __val;								      \
+  })
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
+
+
+#define __lll_robust_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_robust_unlock(futex, private) \
+  __lll_robust_unlock(&(futex), private)
+
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_error.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_error.c
new file mode 100644
index 0000000..81d042a
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_error.c
@@ -0,0 +1 @@
+#include <../../../../../../../libc/sysdeps/linux/metag/__syscall_error.c>
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_rt_sigaction.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_rt_sigaction.c
new file mode 100644
index 0000000..50137c8
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-__syscall_rt_sigaction.c
@@ -0,0 +1 @@
+#include <../../../../../../../libc/sysdeps/linux/common/__syscall_rt_sigaction.c>
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-gettimeofday.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-gettimeofday.c
new file mode 100644
index 0000000..08710f1
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-gettimeofday.c
@@ -0,0 +1,5 @@
+#include <sys/syscall.h>
+#include <sys/time.h>
+
+int gettimeofday (struct timeval *, struct timezone *) attribute_hidden;
+_syscall2(int, gettimeofday, struct timeval *, tv, struct timezone *, tz);
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-vfork.S b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-vfork.S
new file mode 100644
index 0000000..489c749
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pt-vfork.S
@@ -0,0 +1,51 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tcb-offsets.h>
+#include <asm/unistd.h>
+
+#ifdef __PIC__
+#define __VFORK_METAG_LOAD_TP ___metag_load_tp@PLT
+#else
+#define __VFORK_METAG_LOAD_TP ___metag_load_tp
+#endif
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	SETL	[A0StP++], D0FrT, D1RtP; \
+	CALLR	D1RtP, __VFORK_METAG_LOAD_TP; \
+	SUB	D0Re0, D0Re0, #TLS_PRE_TCB_SIZE; \
+	GETD	D0FrT, [D0Re0 + #PID]; \
+	NEG	D0FrT, D0FrT; \
+	SETD	[D0Re0 + #PID], D0FrT; \
+	GETL	D0FrT, D1RtP, [--A0StP];
+
+#define RESTORE_PID \
+	CMP 	D0Re0, #0; \
+	BEQ	1f; \
+	MSETL	[A0StP++], D0Re0, D0FrT; \
+	CALLR	D1RtP, __VFORK_METAG_LOAD_TP; \
+	SUB	D0Re0, D0Re0, #TLS_PRE_TCB_SIZE; \
+	GETD	D0FrT, [D0Re0 + #PID]; \
+	NEG	D0FrT, D0FrT; \
+	SETD	[D0Re0 + #PID], D0FrT; \
+	GETL	D0FrT, D1RtP, [--A0StP]; \
+	GETL	D0Re0, D1Re0, [--A0StP]; \
+1:
+
+#include <../../../../../../../libc/sysdeps/linux/metag/vfork.S>
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pthread_once.c b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pthread_once.c
new file mode 100644
index 0000000..e977a7d
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/pthread_once.c
@@ -0,0 +1,100 @@
+/* Copyright (C) 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+unsigned long int __fork_generation attribute_hidden;
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
+
+int
+attribute_protected
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
+{
+  for (;;)
+    {
+      int oldval;
+      int newval;
+
+      /* Pseudo code:
+	 newval = __fork_generation | 1;
+	 oldval = *once_control;
+	 if ((oldval & 2) == 0)
+	   *once_control = newval;
+	 Do this atomically.
+      */
+      do
+	{
+	  newval = __fork_generation | 1;
+	  oldval = *once_control;
+	  if (oldval & 2)
+	    break;
+	} while (atomic_compare_and_exchange_val_acq (once_control, newval, oldval) != oldval);
+
+      /* Check if the initializer has already been done.  */
+      if ((oldval & 2) != 0)
+	return 0;
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) == 0)
+	break;
+
+      /* Check whether the initializer execution was interrupted by a fork.  */
+      if (oldval != newval)
+	break;
+
+      /* Same generation, some other thread was faster. Wait.  */
+      lll_futex_wait (once_control, oldval, LLL_PRIVATE);
+    }
+
+  /* This thread is the first here.  Do the initialization.
+     Register a cleanup handler so that in case the thread gets
+     interrupted the initialization can be restarted.  */
+  pthread_cleanup_push (clear_once_control, once_control);
+
+  init_routine ();
+
+  pthread_cleanup_pop (0);
+
+  /* Say that the initialisation is done.  */
+  *once_control = __fork_generation | 2;
+
+  /* Wake up all other threads.  */
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+strong_alias (__pthread_once, __pthread_once_internal)
+
+#if defined(__USING_SJLJ_EXCEPTIONS__) && !defined(__PIC__)
+/* When statically linked, if pthread_create is used, this file
+   will be brought in.  The exception handling code in GCC assumes
+   that if pthread_create is available, so are these.  */
+const void *include_pthread_getspecific attribute_hidden = pthread_getspecific;
+const void *include_pthread_setspecific attribute_hidden = pthread_setspecific;
+const void *include_pthread_key_create attribute_hidden = pthread_key_create;
+#endif
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h
new file mode 100644
index 0000000..853ec36
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/sysdep-cancel.h
@@ -0,0 +1,152 @@
+/* Copyright (C) 2003, 2004, 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include <sysdep.h>
+#ifndef __ASSEMBLER__
+# include <pthreadP.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+/* NOTE: We do mark syscalls with unwind annotations, for the benefit of
+   cancellation; but they're really only accurate at the point of the
+   syscall.  The ARM unwind directives are not rich enough without adding
+   a custom personality function.  */
+
+#ifdef __ASSEMBLER__
+#undef ret
+#define ret								\
+   CMP D0Re0, #-4095;							\
+   MOVLO PC, D1RtP;							\
+   MOV D1Ar1, D0Re0;							\
+   B SYSCALL_ERROR;
+#endif /* __ASSEMBLER__ */
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+  .section ".text";							\
+  .type ___##syscall_name##_nocancel,%function;				\
+  .globl ___##syscall_name##_nocancel;					\
+  ___##syscall_name##_nocancel:						\
+    cfi_startproc;							\
+    DO_CALL (syscall_name, args);					\
+    MOV PC, D1RtP;							\
+    cfi_endproc;							\
+  .size ___##syscall_name##_nocancel,.-___##syscall_name##_nocancel;	\
+    .globl _##name;							\
+    .type _##name, @function;						\
+name##:									\
+_##name##:								\
+    DOCARGS_##args;							\
+    SINGLE_THREAD_P;							\
+    UNDOCARGS_##args;							\
+    BNE .Lpseudo_cancel;						\
+    cfi_remember_state;							\
+    DO_CALL (syscall_name, 0);						\
+    ret									\
+    cfi_restore_state;							\
+  .Lpseudo_cancel:							\
+    MSETL [A0StP++], D0FrT, D0.5;					\
+    DOCARGS_##args;	/* save syscall args etc. around CENABLE.  */	\
+    CENABLE;								\
+    MOV D0FrT, D0Re0;	/* put mask in safe place.  */			\
+    UNDOCARGS_##args;	/* restore syscall args.  */			\
+    DO_CALL(syscall_name, 0);	/* do the call.  */			\
+    MOV D0.5, D0Re0;	/* save syscall return value.  */		\
+    MOV D1Ar1, D0FrT;	/* get mask back.  */				\
+    CDISABLE;								\
+    MOV D0Re0, D0.5;	/* retrieve return value.  */			\
+    GETL D0.5, D1.5, [--A0StP];						\
+    GETL D0FrT, D1RtP, [--A0StP];
+
+# define DOCARGS_0
+# define UNDOCARGS_0
+
+# define DOCARGS_1 \
+  SETL [A0StP++], D1Ar1, D0Ar2
+# define UNDOCARGS_1 \
+  GETL D1Ar1, D0Ar2, [--A0StP]
+
+# define DOCARGS_2 DOCARGS_1
+
+# define UNDOCARGS_2 UNDOCARGS_2
+
+# define DOCARGS_3 \
+  MSETL [A0StP++], D1Ar1, D1Ar3
+
+# define UNDOCARGS_3 \
+  GETL D1Ar1, D0Ar2, [--A0StP];		\
+  GETL D1Ar3, D0Ar4, [--A0StP]
+
+# define DOCARGS_4 DOCARGS_3
+# define UNDOCARGS_4 UNDOCARGS_3
+
+# define DOCARGS_5 \
+  MSETL [A0StP++], D1Ar1, D1Ar3, D1Ar5
+# define UNDOCARGS_5 \
+  GETL D1Ar1, D0Ar2, [--A0StP];		\
+  GETL D1Ar3, D0Ar4, [--A0StP];		\
+  GETL D1Ar5, D0Ar6, [--A0StP]
+
+# define DOCARGS_6 DOCARGS_5
+# define UNDOCARGS_6 UNDOCARGS_5
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	CALLR D1RtP, ___pthread_enable_asynccancel@PLT
+#  define CDISABLE	CALLR D1RtP, ___pthread_disable_asynccancel@PLT
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define CENABLE	CALLR D1RtP, ___libc_enable_asynccancel@PLT
+#  define CDISABLE	CALLR D1RtP, ___libc_disable_asynccancel@PLT
+#  define __local_multiple_threads __libc_multiple_threads
+# elif defined IS_IN_librt
+#  define CENABLE	CALLR D1RtP, ___librt_enable_asynccancel@PLT
+#  define CDISABLE	CALLR D1RtP, ___librt_disable_asynccancel@PLT
+# else
+#  error Unsupported library
+# endif
+
+#ifndef __ASSEMBLER__
+#   define SINGLE_THREAD_P						\
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				\
+				   header.multiple_threads) == 0, 1)
+#else
+#  define SINGLE_THREAD_P \
+	SETL	[A0StP++], D0FrT, D1RtP; \
+	CALLR	D1RtP, ___metag_load_tp@PLT; \
+	SUB	D0Re0, D0Re0, #TLS_PRE_TCB_SIZE;	\
+	GETD	D0Re0, [D0Re0 + #MULTIPLE_THREADS_OFFSET]; \
+	CMP	D0Re0, #0; \
+	GETL	D0FrT, D1RtP, [--A0StP]
+#endif
+
+
+#elif !defined __ASSEMBLER__
+
+/* For rtld, et cetera.  */
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/metag/vfork.S b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/vfork.S
new file mode 100644
index 0000000..51fcfbb
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/metag/vfork.S
@@ -0,0 +1,56 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tcb-offsets.h>
+#include <asm/unistd.h>
+
+#ifdef __PIC__
+#define __VFORK_METAG_LOAD_TP ___metag_load_tp@PLT
+#else
+#define __VFORK_METAG_LOAD_TP ___metag_load_tp
+#endif
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	SETL	[A0StP++], D0FrT, D1RtP; \
+	CALLR	D1RtP, __VFORK_METAG_LOAD_TP; \
+	SUB	D0Re0, D0Re0, #TLS_PRE_TCB_SIZE; \
+	GETD	D0FrT, [D0Re0 + #PID]; \
+	NEGS	D0FrT, D0FrT; \
+	BNZ	1f; \
+	MOVT	D0FrT, #0x8000; \
+1:	SETD	[D0Re0 + #PID], D0FrT; \
+	GETL	D0FrT, D1RtP, [--A0StP];
+
+#define RESTORE_PID \
+	CMP 	D0Re0, #0; \
+	BEQ	1f; \
+	MSETL	[A0StP++], D0Re0, D0FrT; \
+	CALLR	D1RtP, __VFORK_METAG_LOAD_TP; \
+	SUB	D0Re0, D0Re0, #TLS_PRE_TCB_SIZE; \
+	GETD	D0FrT, [D0Re0 + #PID]; \
+	NEG	D0FrT, D0FrT; \
+	MOVT	D1Re0, #0x8000; \
+	CMP 	D0FrT, D1Re0; \
+	XOREQ	D0FrT, D0FrT, D0FrT; \
+	SETD	[D0Re0 + #PID], D0FrT; \
+	GETL	D0FrT, D1RtP, [--A0StP]; \
+	GETL	D0Re0, D1Re0, [--A0StP]; \
+1:
+
+#include <../../../../../../../libc/sysdeps/linux/metag/vfork.S>
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h b/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h
index 80d33be..4931a5d 100644
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/not-cancel.h
@@ -22,10 +22,19 @@
 #include <sysdep.h>
 
 /* Uncancelable open.  */
+#if defined(__NR_openat) && ! defined(__NR_open)
+#define open_not_cancel(name, flags, mode) \
+	INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), \
+		(flags), (mode))
+#define open_not_cancel_2(name, flags) \
+	INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), \
+		(flags))
+#else
 #define open_not_cancel(name, flags, mode) \
    INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
 #define open_not_cancel_2(name, flags) \
    INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+#endif
 
 /* Uncancelable openat.  */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/open.S b/libpthread/nptl/sysdeps/unix/sysv/linux/open.S
index 486686a..083141e 100644
--- a/libpthread/nptl/sysdeps/unix/sysv/linux/open.S
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/open.S
@@ -5,6 +5,12 @@ extern int __open_nocancel (const char *, int, ...) attribute_hidden;
 */
 #if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
 
+/*
+ * override the hidden open symbol with this one when
+ * we don't have openat() defined. Otherwise we will use
+ * the common wrapper
+ */
+#if defined(__NR_open)
 PSEUDO (__libc_open, open, 3)
 ret
 PSEUDO_END(__libc_open)
@@ -16,6 +22,6 @@ libc_hidden_weak (__open)
 weak_alias (__libc_open, open)
 libc_hidden_weak (open)
 
-
+#endif
 
 #endif
diff --git a/libpthread/nptl/sysdeps/unix/sysv/linux/openat.S b/libpthread/nptl/sysdeps/unix/sysv/linux/openat.S
new file mode 100644
index 0000000..468154b
--- /dev/null
+++ b/libpthread/nptl/sysdeps/unix/sysv/linux/openat.S
@@ -0,0 +1,22 @@
+#include <sysdep-cancel.h>
+
+/*
+extern int __openat_nocancel (const char *, int, ...) attribute_hidden;
+*/
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+#if defined(__NR_openat)
+PSEUDO (__libc_openat, openat, 4)
+ret
+PSEUDO_END(__libc_openat)
+
+libc_hidden_def (__openat_nocancel)
+libc_hidden_def (__libc_openat)
+weak_alias (__libc_openat, __openat)
+libc_hidden_weak (__openat)
+weak_alias (__libc_openat, openat)
+libc_hidden_weak (openat)
+
+#endif
+
+#endif
diff --git a/libubacktrace/sysdeps/metag/Makefile.arch b/libubacktrace/sysdeps/metag/Makefile.arch
new file mode 100644
index 0000000..9b0de38
--- /dev/null
+++ b/libubacktrace/sysdeps/metag/Makefile.arch
@@ -0,0 +1,12 @@
+# Makefile for uClibc (sh/libubacktrace)
+#
+# Copyright (C) 2010 STMicroelectronics Ltd
+# Author: Carmelo Amoroso <carmelo.amoroso@st.com>
+
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+libubacktrace_ARCH_SRC-y := backtrace.c
+
+# -fexections is required for backtrace to work using dwarf2
+CFLAGS-backtrace.c := -fexceptions
diff --git a/libubacktrace/sysdeps/metag/backtrace.c b/libubacktrace/sysdeps/metag/backtrace.c
new file mode 100644
index 0000000..18b91b1
--- /dev/null
+++ b/libubacktrace/sysdeps/metag/backtrace.c
@@ -0,0 +1,84 @@
+/*
+ * Perform stack unwinding by using the _Unwind_Backtrace.
+ *
+ * User application that wants to use backtrace needs to be
+ * compiled with -fexceptions option and -rdynamic to get full
+ * symbols printed.
+ *
+ * Copyright (C) 2009, 2010 STMicroelectronics Ltd.
+ *
+ * Author(s): Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ * - Initial implementation for glibc
+ *
+ * Author(s): Carmelo Amoroso <carmelo.amoroso@st.com>
+ * - Reworked for uClibc
+ *   - use dlsym/dlopen from libdl
+ *   - rewrite initialisation to not use libc_once
+ *   - make it available in static link too
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ *
+ */
+
+#include <execinfo.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <unwind.h>
+#include <assert.h>
+#include <stdio.h>
+
+struct trace_arg
+{
+  void **array;
+  int cnt, size;
+};
+
+static _Unwind_Reason_Code (*unwind_backtrace) (_Unwind_Trace_Fn, void *);
+static _Unwind_Ptr (*unwind_getip) (struct _Unwind_Context *);
+
+static void backtrace_init (void)
+{
+	void *handle = dlopen ("libgcc_s.so.1", RTLD_LAZY);
+
+	if (handle == NULL
+		|| ((unwind_backtrace = dlsym (handle, "_Unwind_Backtrace")) == NULL)
+		|| ((unwind_getip = dlsym (handle, "_Unwind_GetIP")) == NULL)) {
+		printf("libgcc_s.so.1 must be installed for backtrace to work\n");
+		abort();
+	}
+}
+
+static _Unwind_Reason_Code
+backtrace_helper (struct _Unwind_Context *ctx, void *a)
+{
+	struct trace_arg *arg = a;
+
+	assert (unwind_getip != NULL);
+
+	/* We are first called with address in the __backtrace function. Skip it. */
+	if (arg->cnt != -1)
+		arg->array[arg->cnt] = (void *) unwind_getip (ctx);
+	if (++arg->cnt == arg->size)
+		return _URC_END_OF_STACK;
+	return _URC_NO_REASON;
+}
+
+/*
+ * Perform stack unwinding by using the _Unwind_Backtrace.
+ *
+ * User application that wants to use backtrace needs to be
+ * compiled with -fexceptions option and -rdynamic to get full
+ * symbols printed.
+ */
+int backtrace (void **array, int size)
+{
+	struct trace_arg arg = { .array = array, .size = size, .cnt = -1 };
+
+	if (unwind_backtrace == NULL)
+		backtrace_init();
+
+	if (size >= 1)
+		unwind_backtrace (backtrace_helper, &arg);
+
+	return arg.cnt != -1 ? arg.cnt : 0;
+}
diff --git a/test/math/libm-test-ulps-metag b/test/math/libm-test-ulps-metag
new file mode 100644
index 0000000..cf58ba6
--- /dev/null
+++ b/test/math/libm-test-ulps-metag
@@ -0,0 +1,180 @@
+# Begin of automatic generation
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+
+# erf
+Test "erf (0.75) == 0.711155633653515131598937834591410777":
+double: 1
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+
+# erfc
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+
+# exp
+Test "exp (1) == e":
+double: 1
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+
+# j1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+double: 1
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+double: 1
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+
+# lgamma
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+
+# y0
+Test "y0 (0.75) == -0.137172769385772397522814379396581855":
+double: 1
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 1
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+
+# yn
+Test "yn (0, 0.75) == -0.137172769385772397522814379396581855":
+double: 1
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 1
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+
+# Maximal error of functions:
+Function: "cos":
+double: 2
+
+Function: "erf":
+double: 1
+
+Function: "erfc":
+double: 1
+
+Function: "exp":
+double: 1
+
+Function: "expm1":
+double: 1
+
+Function: "j0":
+double: 2
+
+Function: "j1":
+double: 1
+
+Function: "jn":
+double: 4
+
+Function: "lgamma":
+double: 1
+
+Function: "log10":
+double: 1
+
+Function: "tan":
+double: 1
+
+Function: "y0":
+double: 1
+
+Function: "y1":
+double: 3
+
+Function: "yn":
+double: 3
+
+# end of automatic generation
diff --git a/utils/ldd.c b/utils/ldd.c
index 04fbbc6..83ef9f7 100644
--- a/utils/ldd.c
+++ b/utils/ldd.c
@@ -63,6 +63,11 @@
 #define ELFCLASSM	ELFCLASS32
 #endif
 
+#if defined(__metag__)
+#define MATCH_MACHINE(x) (x == EM_METAG)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #if defined(__mips__)
 #define MATCH_MACHINE(x) (x == EM_MIPS || x == EM_MIPS_RS3_LE)
 #define ELFCLASSM	ELFCLASS32
